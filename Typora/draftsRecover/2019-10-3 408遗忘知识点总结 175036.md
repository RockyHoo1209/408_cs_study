# 408遗忘知识点总结

## 组原

### 第一章

- 第一台电子数字计算机:ENIAC

  | 单指令和单数据流系统SISD | 单指令多数据流系统SIMD | 多指令单数据流系统MISD | 多指令多数据流系统MIMD |
  | ------------------------ | ---------------------- | ---------------------- | ---------------------- |
  | 冯诺依曼体系结构         | 阵列处理器和向量处理器 | ________               | 多处理器和多计算机系统 |

- 冯诺依曼机的特点(SISD)

  ![1569841926106](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569841926106.png)

- 累加器 :是一种**寄存器**，用来储存计算产生的中间结果。

- 一个汉字通常占2B

### 第三章

- 存储元:存放一个二进制位的物理器件

- 存储单元:存放一个**机器字**的所有存储元;地址码相同的多个**存储元**构成存储单元

- SRAM DRAM各自得特点


![1569747278920](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569747278920.png)

2、三种映射方式得地址结构

![1569748348509](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748348509.png)
![1569748562645](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748562645.png)
![1569748592130](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748592130.png)





## OS

### 概述

- 并发和并行的区别:

  | 并发                                   | 并行                                 |
  | -------------------------------------- | ------------------------------------ |
  | 两个或以上事件在**同一时间间隔**内发生 | 具有可以**同时**进行运算或操作的特性 |

  例:	并发是一手筷子，一手电话，说一句话，咽一口饭。
  		 并行是咽一口饭同时说一句话，而这光靠一张嘴是办不到的，至少两张嘴。

- 操作系统最基本的两个特性:并发行 共享性

- 原语

  ![1569839846080](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569839846080.png)
  
- 核心态(管态):进入核心态是通过**硬件**实现的；
- 用户态
- 特权指令与非特权指令:**用户态**下可以使用**非特权指令**，用户态下使用特权指令将产生**中断**阻止用户使用特权指令；**核心态**下可以使用所有指令；因此，用户程序放在用户态运行；**操作系统必须使用特权指令的部分放在核心态运行。**

- 中断(外中断):来自**cpu**以外；异常(内中断\陷入)：如地址越界、算术溢出等,源自**cpu**；**系统调用的实现；**

- 大内核:将操作系统的主要功能模块作为整体来运行；代码难以维护

- 微内核:保留内核的基本功能，其他移交至**用户态**；性能较低

- 访管指令与访管中断

  ![1570006519304](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570006519304.png)

  **注**：进程是进程实体的运行过程，是系统进行**资源分配和调度**的一个**独立单位**

### 进程管理

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009692731.png" alt="1570009692731" style="zoom:80%;" />

- PCB(进程控制块)相关概念:
  - **程序段、相关数据段、PCB**三部分描述程序的基本情况和运行状态；这三部分相应地构成**进程映像**
  - **创建进程**实质上时创建进程映像中的PCB;撤销进程时**撤销进程**的PCB，**进程映像是静态的，进程是动态的**
  - PCB是进程存在的唯一标志
  - 将各种PCB组织起来的方式:链接和索引
- 进程的定义

![1570009447787](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009447787.png)

- 就绪态和等待态的区别:就绪态等待**处理机**，等待态等待**处理机外的其他资源**

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009991483.png" alt="1570009991483" style="zoom:80%;" />

**注**：一个进程从**运行态$\to$阻塞态**是一个主动的行为，从**阻塞态$\to$就绪态**是被动行为

- 进程间的通信

  - 共享存储(通过**系统**提供的**发送消息**和**接收消息**两个原语进行)

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011348471.png" alt="1570011348471" style="zoom:80%;" />

  - 消息传递

  ![1570011392948](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011392948.png)

  **注**:消息传递分为**直接通信**和**间接通信(电子邮件)**

  - 管道通信

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011613060.png" alt="1570011613060" style="zoom:80%;" />
    **注:**管道机制必须提供以下三方面的协调能力,**互斥 同步 确定对方存在**

    ​	管道只能工作在**半双工**;工作时写进程会先把缓冲区写满,然后才让读进程读

    ​	管道大小限制,一般为4kb,本质上其是一个文件,是**消息传递**的一种特殊方式

- 线程的基本概念及属性:

  - **引入进程**是为了更好地使躲到程序并发执行;**引入线程**是为了减小程序并发执行付出的时空开销,提高并发性能.
  - 线程是一个基本地**CPU执行单元**,程序执行流地**最小单元**,是被系统独立调度和分派的基本单位,**线程不拥有系统资源**
  - 不同进程线程的切换才会引起进程的切换
  - 不同的线程可以执行相同的程序,即同一个服务程序被不同用户调用时**,OS会创建不同的线程**

- 线程的实现方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570012768484.png" alt="1570012768484" style="zoom: 67%;" />		

**注**:线程的多(用户级)对一(内核级)\一对一\多对多

- 调度层次
  - 作业调度(高级调度):**内存**与**外存**间的调度
  - 内存调度(中级调度):提高内存利用率和系统吞吐量
  - 进程调度(低级调度):从就绪队列中选区一个进程，分配处理机

![1570086852555](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570086852555.png)

- 系统吞吐量:单位时间**CPU**完成作业的数量

- 周转时间:作业从**提交**到**完成**所经历的时间;周转时间=作业完成时间-作业提交时间​

  带权周转时间=作业调度时间/作业实际运行时间

- 高响应比调度算法: 响应比=(等待时间+要求服务时间)/要求服务时间

- 多级反馈队列调度算法:

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570087722077.png" alt="1570087722077" style="zoom:67%;" />

- 临界资源:一次只能有一个进程使用的资源；临界区:访问临界资源的**代码段**

- 同步和互斥的区别:

  - 同步:进程间相互合作，如:消费者-生产者关系
  - 互斥:使用临界资源时,有一个进程在使用，另一个等待

- 临界区互斥的基本方法

  - 软件方法

    - 单标志法:需要进程交替进行，若一进程不打算进入临界区，则另一进程循环等待

    - 双标志法先检查(自己的临界区资源是否被访问):优点:不用交替进入  缺点:进程可能同时进入临界区

    - 双标志法后检查(自己..):先检查对方，再标志自己。会导致**饥饿(死锁)现象**

      [^注:]: 1、饥饿进程可以只有一个,而死锁进程至少两个2、饥饿可以是一个就绪进程,死锁时阻塞进程

    - peterson算法

      ![1570090848857](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570090848857.png)

  - 硬件方法

    - TestAndSet Swap指令由逻辑电路直接实现，**不会被中断**

- 管程的一些重要概念

  - 管程是由一组数据以及定义再这组数据上对这组数据的操作组成的**软件模块**(类似于抽象类)
  - 管程的基本特性

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091943965.png" alt="1570091943965" style="zoom: 67%;" />
  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091982112.png" alt="1570091982112" style="zoom:67%;" />



### 第三章

三种分页方式的地址结构

1.分页

![1569833278353](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833278353.png)

- 多级页表

![1569833343596](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833343596.png)
3.分段

![1569833453418](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833453418.png) 	

- 段表的内容

![1569833495519](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833495519.png)

4、段页式

![1569833654898](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833654898.png)

## DS

### 数组和广义表

- **三元组**矩阵的转置，经历了三个步骤：

  - 矩阵的行数 n 和列数 m 的值交换；

  - 将三元组中的i和j调换；

  - 转换之后的表同样按照行序（置换前的列序）为主序，进行排序；

    (例:三元组的转置很简单,只需交换i,j的值,						答案:错误)

### 排序

```c++
///希尔排序
for(int id=n>>1;id>=1;id<<=1){
    for(int i=1;i<=n;i++)
    if(a[i]>a[i+id]){
        a[0]=a[i+id];
        for(int j=i-id;j>0&&a[0]<a[j];j-=id){
            a[j+id]=a[j];
        }
        a[j+id]=a[0];
    }
}
```

```r
///冒泡排序
void swap(int a,int b){///O(0) swap
    a=a+b;
    b=a-b;
    a=a-b;
}

for(int i=n;i>=1;i--){
    flag=false;
    for(int j=n;j>i;j--) if(a[i]<a[i-1]) swap(a[i],a[i-1]),flag=true;
    if(!flag) return;
}

///简单选择排序
for(int i=0;i<n-1;i++){
    int min=i;
    int j;
    for(j=i+1;j<n;j++){
        if(a[min]>a[j]) min=j;
    }
    if(min!=i) swap(a[j],a[min])
}
///注:简单选择排序和冒泡排序有相似,要区分
///区别在于:选择排序每次都会把最小的和当前这趟首元素交换位置,
```

```c++
///快排
int l=1,r=n;
int Partition(int a[],int l,int r){
    int pivot=a[l];
	while(l<r){
        while(l<r&&a[r]>=pivot) r--;
        a[l]=a[r];
        while(l<r&&a[l]<=pivot) l++;
        a[r]=a[l];
    }
    a[l]=pivot;
    return low;
}

void Qsort(int a[],int l,int r){
    if(l,r){
    int pivotpos=Partition(a,lr);
    Qsort(a,l,pivotpos);
    Qsort(a,pivotpos+1,r);
    }
}
```

```c++
///堆排序(大根堆)

void stiffDown(int a[],int k,int len){
    int a[0]=a[k];
    fot(int ch=k<<1;ch<=len;ch<<=2){
        if(ch<len&&a[ch+1]>a[ch]) ch++;
        if(a[0]>=a[ch]) break;
        a[k]=a[ch];
        k=ch;
    }
    a[k]=a[0];
}

void stiffUp(int a[],int k,int len){
    int a[0]=a[k];
	for(int pa=k>>1;pa>0;pa>>=1){
        if(a[0]>a[pa]) a[k]=a[pa]; else break;
        k=pa;
    }
    a[k]=a[0];
}

void buildMaxHeap(int a[],int len){
    for(int i=(len>>1);i>0;i--) stiffDown(a,i,len);
}

void deleteTop(int a[]){
    swap(a[1],a[len]);
    a[len--]=-1;
    stiffDown(a,1,len);
}

void insert(int a[],int k){
    a[len++]=k;
    stiffUp(a,len);
}

void heapSort(int a[],int len){
    buildMaxHeap(a,len);
    for(int i=len;i>0;i--){
        swap(a[1],a[i]);
        stiffDown(a,1,i-1)
    } 
}
```

```c++
///归并排序
void Merge(int a[],int l,int r){
    for(int i=l;i<=r;i++) B[i]=A[i];
    int mid=(l+r)>>1;
    int i;
    for(int i=0,k=l,j=mid+1;i<=mid&&j<=r;k++){
        if(B[i]<=B[j]) A[k]=B[i++];
        else A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=r) A[k++]=B[j]++;
}

void mergeSort(int a[],int l,int r){
    int mid=(l+r)>>1;
    mergeSort(a,l,mid);
    mergeSort(a,mid+1,r);
    merge(a,l,r);
}
```

- 基数排序

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000636226.png" alt="1570000636226" style="zoom:80%;" />

各种内排序的比较

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000696976.png" alt="1570000696976" style="zoom:80%;" />

​			**算法复杂度**与初始状态无关的有：**选择排序、堆排序、归并排序、基数排序。**

​			元素总**比较次数**与初始状态无关的有：**选择排序**、**基数排序**  **折半插入排序**。

​			元素总**移动次数**与初始状态无关的有：**归并排序**、**基数排序**。

- 外部排序

  	多路归并

![1570001947191](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570001947191.png)
**注**：理论上，增大躺数可以减少归并次数；归并趟数=$ceil(log_mr)$

​	  

​		败者树(消除m路归并,增大归并路数的影响)

![1570002634614](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570002634614.png)
			置换-选择排序

![1570003607744](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003607744.png)
![1570003716126](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003716126.png)
![1570003755469](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003755469.png)



​		最佳归并树(多路汉夫曼树):掌握不能构成严格哈夫曼树时如何新增结点

![1570004972627](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570004972627.png)

## 网络

### 计算机网络体系结构

- 计算机网络的分类

| 按分布范围划分           | 按传输技术划分   | 按使用者划分  | 按交换技术划分             | 按拓扑结构划分      | 按传输介质 |
| ------------------------ | ---------------- | ------------- | -------------------------- | ------------------- | ---------- |
| 广域网、域域网 局域网... | 广播网、点对点网 | 公用网 专用网 | 电路交换 报文交换 分组交换 | 星形 环形 总线 网状 | 蓝牙..     |

- 总时延=发送时延(**传输时延**)+**传播时延**+处理时延+排队时延
  - 发送时延=分组长度/信道宽度
  - 传播时延:信道长度/电磁波在信道上的传播速度
  - 一般题目未提及，忽略处理时延和排队时延
- 时延带宽积=第一个比特到达终点时，发送端已经发送的比特数。直观上=传播时延*信道带宽
- 数据帧的抽象结构
  - 服务数据单元(SDU)：完成要求功能而应传送的数据
  - 协议控制信息(PCI)：控制协议操作的信息
  - 协议数据单元(PDU):**对等层之间**传送数据的的单位
  - 三者间的挂你:n-PCI+n-SDU=n-PDU=(n-1)-SDU
- OSI与TCP/IP的比较

| OSI        | TCP/IP                              | 协议栈                                           |
| ---------- | ----------------------------------- | ------------------------------------------------ |
| 应用层     | 应用层                              | telnet\ftp\dns\smtp\http                         |
| 表示层     | 应用层                              | --------                                         |
| 会话层     | 应用层                              | --------                                         |
| 传输层     | 传输层                              | TCP\UDP                                          |
| 数据链路层 | 网际层                              | SDLC\HDLC\PPP\STP\IP\IPX\OSPF\ICMP\IGMP\ARP\RARP |
| 物理层     | 网络接口层(网络接口$\to{}$物理接口) | EIA\CCITT                                        |

