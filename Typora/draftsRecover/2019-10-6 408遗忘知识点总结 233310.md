# <u408</u>遗忘知识点总结

## 组原

### 第一章

- 第一台电子数字计算机:ENIAC

  | 单指令和单数据流系统SISD | 单指令多数据流系统SIMD | 多指令单数据流系统MISD | 多指令多数据流系统MIMD |
  | ------------------------ | ---------------------- | ---------------------- | ---------------------- |
  | 冯诺依曼体系结构         | 阵列处理器和向量处理器 | ________               | 多处理器和多计算机系统 |

- 冯诺依曼机的特点(SISD)

  ![1569841926106](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569841926106.png)

- 累加器 :是一种**寄存器**，用来储存计算产生的中间结果。

- 一个汉字通常占2B

### 数据的表示和运算

- 校验码
  - 码距:任意两个合法码之间最少变化的二进制位数;码距>=2，开始具备检错能力;码距越大，检\纠错能力越强,纠错能力>=检错能力
- 奇偶校验码

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279195718.png" alt="1570279195718" style="zoom:80%;" />

- 海明码(<u>发现双比特错,纠正单笔比特错</u>):表示法方法(n,k) n位编码,数据位k位

  - L-1=D+C (D>=C) L:最小码距 D:检错位数 C:纠错位数

    [^注]: 海明码检错d位,码距至少d+1(令上式D=0)  纠错d位,码距至少2d+1(令D=C=d)

- 海明码求解步骤(练习参见袁书习题)

  ![1570279987658](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279987658.png)

![1570279816177](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279816177.png)

- 例2

  ![1570281565897](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281565897.png)

- 循环冗余码(CRC)

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281702819.png" alt="1570281702819" style="zoom: 80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281737694.png" alt="1570281737694" style="zoom:80%;" />

- 强制转化(具体参考CSAPP)

| int$\to$float            | int/float$\to$double | double$\to$float  | floatdouble$\to$int |
| ------------------------ | -------------------- | ----------------- | ------------------- |
| 不会溢出,但会<u>舍入</u> | 能够保留精确的数值   | 可能溢出,可能舍入 | 向零舍入            |



### 存储系统

- 存储元:存放一个二进制位的物理器件

- 存储单元:存放一个**机器字**的所有存储元;地址码相同的多个**存储元**构成存储单元

- SRAM DRAM各自得特点


![1569747278920](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569747278920.png)

2、三种映射方式得地址结构

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748348509.png" alt="1569748348509" style="zoom:80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748562645.png" alt="1569748562645" style="zoom:80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748592130.png" alt="1569748592130" style="zoom:80%;" />

### 指令系统

- 指令的基本格式
  - 二地址指令<u>:目的操作数</u>用于保存本次<u>运算结果</u>(大题中出现二地址指令,默认知道此条)

### 总线

- 常见总线标准

| 系统总线 | 局部总线                      | 设备总线 | 其他                               |
| -------- | ----------------------------- | -------- | ---------------------------------- |
| ISA      | VESA\PCI(<u>即插即用)</u>\AGP | USB      | EISA\PCI-E\RS-232C\PCMCIA\IDE\SATA |

### I/O系统

| 单重中断                               | 多重中断(中断嵌套)                           |
| -------------------------------------- | -------------------------------------------- |
| 关中断**(中断隐指令)**(向下到保护现场) | 关中断(**中断隐指令)**向下到保护现场)        |
| 保存断点(pc)                           | 保存断点(pc)                                 |
| 送中断向量                             | 送中断向量                                   |
| 保护现场**(中断服务程序)**(向下都是)   | 保护现场和屏蔽字**(中断服务程序)**(向下都是) |
| ---------                              | 开中断                                       |
| 执行中断服务程序                       | 执行中断服务程序                             |
| ----------                             | 关中断                                       |
| 恢复现场                               | 恢复现场和屏蔽字                             |
| 开中断                                 | 开中断                                       |
| 中断返回                               | 中断返回                                     |

[^注]: 中断向量号



## OS

### 概述

- 并发和并行的区别:

  | 并发                                   | 并行                                 |
  | -------------------------------------- | ------------------------------------ |
  | 两个或以上事件在**同一时间间隔**内发生 | 具有可以**同时**进行运算或操作的特性 |

  例:	并发是一手筷子，一手电话，说一句话，咽一口饭。
  		 并行是咽一口饭同时说一句话，而这光靠一张嘴是办不到的，至少两张嘴。

- 操作系统最基本的两个特性:并发行 共享性

- 原语

  ![1569839846080](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569839846080.png)
  
- 核心态(管态):进入核心态是通过**硬件**实现的；
- 用户态
- 特权指令与非特权指令:**用户态**下可以使用**非特权指令**，用户态下使用特权指令将产生**中断**阻止用户使用特权指令；**核心态**下可以使用所有指令；因此，用户程序放在用户态运行；**操作系统必须使用特权指令的部分放在核心态运行。**

- 中断(外中断):来自**cpu**以外；异常(内中断\陷入)：如地址越界、算术溢出等,源自**cpu**；**系统调用的实现；**

- 大内核:将操作系统的主要功能模块作为整体来运行；代码难以维护

- 微内核:保留内核的基本功能，其他移交至**用户态**；性能较低

- 访管指令与访管中断

  ![1570006519304](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570006519304.png)

  **注**：进程是进程实体的运行过程，是系统进行**资源分配和调度**的一个**独立单位**

### 进程管理

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009692731.png" alt="1570009692731" style="zoom:80%;" />

- PCB(进程控制块)相关概念:
  - **程序段、相关数据段、PCB**三部分描述程序的基本情况和运行状态；这三部分相应地构成**进程映像**
  - **创建进程**实质上时创建进程映像中的PCB;撤销进程时**撤销进程**的PCB，**进程映像是静态的，进程是动态的**
  - PCB是进程存在的唯一标志
  - 将各种PCB组织起来的方式:链接和索引
- 进程的定义

![1570009447787](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009447787.png)

[^注]: 进程

- 就绪态和等待态的区别:就绪态等待**处理机**，等待态等待**处理机外的其他资源**

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009991483.png" alt="1570009991483" style="zoom:80%;" />

**注**：一个进程从**运行态$\to$阻塞态**是一个主动的行为，从**阻塞态$\to$就绪态**是被动行为

- 进程间的通信

  - 共享存储(通过**系统**提供的**发送消息**和**接收消息**两个原语进行)

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011348471.png" alt="1570011348471" style="zoom:80%;" />

  - 消息传递

  ![1570011392948](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011392948.png)

  **注**:消息传递分为**直接通信**和**间接通信(电子邮件)**

  - 管道通信

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011613060.png" alt="1570011613060" style="zoom:80%;" />
    **注:**管道机制必须提供以下三方面的协调能力,**互斥 同步 确定对方存在**

    ​	管道只能工作在**半双工**;工作时写进程会先把缓冲区写满,然后才让读进程读

    ​	管道大小限制,一般为4kb,本质上其是一个文件,是**消息传递**的一种特殊方式

- 线程的基本概念及属性:

  - **引入进程**是为了更好地使躲到程序并发执行;**引入线程**是为了减小程序并发执行付出的时空开销,提高并发性能.
  - 线程是一个基本地**CPU执行单元**,程序执行流地**最小单元**,是被系统独立调度和分派的基本单位,**线程不拥有系统资源**
  - 不同进程线程的切换才会引起进程的切换
  - 不同的线程可以执行相同的程序,即同一个服务程序被不同用户调用时**,OS会创建不同的线程**

- 线程的实现方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570012768484.png" alt="1570012768484" style="zoom: 67%;" />		

**注**:线程的多(用户级)对一(内核级)\一对一\多对多

- 调度层次
  - 作业调度(高级调度):**内存**与**外存**间的调度
  - 内存调度(中级调度):提高内存利用率和系统吞吐量
  - 进程调度(低级调度):从就绪队列中选区一个进程，分配处理机

![1570086852555](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570086852555.png)

- 系统吞吐量:单位时间**CPU**完成作业的数量

- 周转时间:作业从**提交**到**完成**所经历的时间;周转时间=作业完成时间-作业提交时间​

  带权周转时间=作业调度时间/作业实际运行时间

- 高响应比调度算法: 响应比=(等待时间+要求服务时间)/要求服务时间

- 多级反馈队列调度算法:

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570087722077.png" alt="1570087722077" style="zoom:67%;" />

- 临界资源:一次只能有一个进程使用的资源；临界区:访问临界资源的**代码段**

- 同步和互斥的区别:

  - 同步:进程间相互合作，如:消费者-生产者关系
  - 互斥:使用临界资源时,有一个进程在使用，另一个等待

- 临界区互斥的基本方法

  - 软件方法

    - 单标志法:需要进程交替进行，若一进程不打算进入临界区，则另一进程循环等待

    - 双标志法先检查(自己的临界区资源是否被访问):优点:不用交替进入  缺点:进程可能同时进入临界区

    - 双标志法后检查(自己..):先检查对方，再标志自己。会导致**饥饿(死锁)现象**

      [^注:]: 1、饥饿进程可以只有一个,而死锁进程至少两个2、饥饿可以是一个就绪进程,死锁时阻塞进程

    - peterson算法

      ![1570090848857](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570090848857.png)

  - 硬件方法

    - TestAndSet Swap指令由逻辑电路直接实现，**不会被中断**

- 管程的一些重要概念

  - 管程是由一组数据以及定义再这组数据上对这组数据的操作组成的**软件模块**(类似于抽象类)
  - 管程的基本特性

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091943965.png" alt="1570091943965" style="zoom: 67%;" />
  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091982112.png" alt="1570091982112" style="zoom:67%;" />

- 死锁产生的必要条件

  - 互斥条件:

  - 不剥夺条件

  - 请求和保持

  - 循环等待

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570202852864.png" alt="1570202852864" style="zoom: 50%;" />

[^注]: 循环等待不等同于死锁,前者是后者的必要条件 资源分配图含圈系统不一定死锁(同类资源数>1)

- 死锁的处理策略

  - 预防死锁

    - 破坏互斥条件
    - 破坏不可剥夺
    - 破坏请求和保持
    - 破坏循环等待

  - 避免死锁

    - 系统安全状态:系统可按照某进程推进顺序为每个进程分配资源,使每个进程都可顺利完成

      [^注]: 并非所有不安全状态都是死锁状态，只是可能进入死锁;只要系统处于安全状态就不会死锁

    - 银行家算法

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372314796.png" alt="1570372314796" style="zoom:80%;" />
    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372363483.png" alt="1570372363483" style="zoom:80%;" />

  - 死锁检测和解除

    - 资源分配图:框表示资源 圈表示进程;从进程(资源)到资源(进程)的有向边叫<u>请求边</u>(<u>分配边</u>),

      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372456734.png" alt="1570372456734" style="zoom:70%;" />

    - 死锁定理:简化资源分配图

    - 死锁解除

      - 资源剥夺法
      - 撤销进程法

    [^注]: 预防死锁和避免死锁都是事先预防策略



### 内存管理

- 内存管理的功能:空间的分配回收、地址转换、空间的扩充、存储保护
- 将源程序变成可执行的程序需要:
  - 1、编译:形成目标模块  2、链接:将目标模块与所需库函数链接在一起 3、装入
- 程序链接的三种方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570287607907.png" alt="1570287607907" style="zoom:80%;" />

- 装入模块的三种方式

  - 绝对装入:编译程序根据程序将驻留在内存的位置产生<u>绝对地址</u>；由于程序的逻辑地址和实际地址完全相同,故无需对程序和数据地址进行修改

  - 可重定位装入:程序中的地址从"0"开始,根据情况装入内存的适当位置

    [^注1]: 重定位:装入时对目标程序的指令和数据的修改过程;地址变换通常是在装入时一次完成的,所以又称<u>静态重定位</u>。
    [^注2]: 静态重定位的特点:a.作业装入内存时必须分配其要求的全部内存空间；b.作业一旦进入内存,整个运行期间不能在内存中移动,也不能申请内存空间

  - 动态运行时装入(动态重定位):程序在内存中若发生移动,采用动态装入.

    - 装入内存的所有地址均为**相对地址**
    - 需要**重定位寄存器**的支持
    - 可以将程序分配到<u>不连续</u>的存储区，运行期间可以动态申请内存

- 址重定位:通过 地址转换将<u>逻辑地址</u>变成<u>物理地址</u>
- 重定位和界地址寄存器的硬件支持

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570288976486.png" alt="1570288976486" style="zoom:67%;" />

|          | 覆盖                                                         | 交换                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 主要思想 | 将用户空间分成<u>固定区</u>和<u>覆盖区</u>,活跃的部分在固定区,其余部分调用关系分段<br />将即将要访问的段调入<u>覆盖区</u>,其他在<u>外存</u>中 | 换出:把处于等待的程序从内存移到外存<br />换入:把就绪进程放入内存 |
| 特点     | ------                                                       | 交换需要备份存储<br />需要每个进程的执行时间>交换时间；影响交换时间的主要是<u>转移时间</u><br />若换出进程,则保证济南城完全处于空闲状态<br />空间吃紧时启动，负荷降低就暂停 |
| 缺点     | 运行的代码量大于主存时不能运行;内存中能更新的只有覆盖区的段  | -----                                                        |

[^注]: 交换主要在不同进程间进行,覆盖(过时)则用于同一个程序或进程

- 连续分配管理方式

  - 单一连续分配:内存中只有一道程序

  - 固定分区分配:是一种<u>多道程序存储管理方式</u>，每个分区只装入一道作业；又分分区大小相等与不等

  - 动态分区分配:在**装入时**根据进程的大小动态建立分区;分区大小和数目可变;会产生**外部碎片**，可通过**紧凑技术**解决

    [^注]: 外部碎片是分区间的空闲内存区,内部碎片是分区内的空闲内存区

    - <u>动态分区</u>的分配算法

      - 首次适应:分配区内按顺序查找,找到满足要求的第一个空闲分区

      - 最佳适应:空闲分区<u>按容量递增</u>，找到第一个能满足要求的空闲分区

      - 最坏适应:空闲分区<u>按容量递减</u>，找到第一个能满足要求的空闲分区

      - 邻近适应(<u>循环首次适应</u>):和首次适应相似，区别是每次从上次查找结束的地方开始

        [^注]: 首次适应一般最简单，也是最快的；首次适应可能比最佳适应好,但它们两者一定比最大适应号

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570374233039.png" alt="1570374233039" style="zoom:80%;" />

- 非连续存储方式

  - 三种分页方式的地址结构

  1.分页

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833278353.png" alt="1569833278353" style="zoom: 80%;" />

  - 多级页表

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833343596.png" alt="1569833343596" style="zoom:80%;" />
  3.分段

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833453418.png" alt="1569833453418" style="zoom:80%;" /> 	

  - 段表的内容

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833495519.png" alt="1569833495519" style="zoom:80%;" />

  4、段页式

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833654898.png" alt="1569833654898" style="zoom:80%;" />

  | 分页管理                                                     | 分段管理                                                     | 段页式管理                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
  | 每个进程建立一张页表(内存)                                   | 一个进程一张段表                                             | 一个进程一张段表，每个段一张页表             |
  | 设置一个页表寄存器(PTR)，存放<u>内存始址</u>和<u>页表长度</u>;进程未执行时页表的始址和长度都放在进程控制块(PCB)中;<br />多级页表的顶级页表只能有一个页;多级页表增加 | 段内要求连续，段间不要求;<br />设置<u>段表寄存器</u>，<br />分段管理保护方式:1、存取控制保护 2、地址越界保护 | 在一个<u>进程</u>中段表只有一个,页表可能多个 |
  |                                                              |                                                              |                                              |

  [^注]: 页表长度:一共有多少页; 页表项长度:页地址占多大存储空间

  

  ### 文件管理

- 文件共享

  - 硬链接(基于索引结点):

    - 文件A是文件B的硬链接，则A的目录项中的索引节点号与B节点的**索引节点号相同**，既一个inode节点对应两个不同的文件名

    - 两个文件名指向一个同一个文件,A和B对于文件系统其实是完全相同的. **如果删除了其中一个，对另外一个没有影响.** 
    - 每增加一个文件名，索引节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，索引节点和对应数据块被回收. 
    - 只能对已存在的文件进行创建；

  - 软连接

    - A是B的软链接，A的目录项中的inode节点号与B的目录项中的**inode节点号不同**，A和B指向的是两个不同的inode，继而指向两块不同的数据块，但是<u>A的数据块存放的知识B的路径名</u>. 
    - 如果B被删除了，A仍然存在,但指向的是一个无效的链接.
    - 创建软链接时，链接计数不会增加；
    - 链接有自己的文件属性及权限等
    - 可对不存在的文件或目录创建软链接
    - 只有文件的拥有着才拥有指向其索引结点的指针

- 磁盘调度算法

  - 循环扫描(cscan):<u>磁头只需要移动到最远端的一个请求即可，不需要到达磁盘端点</u>

## DS

### 数组和广义表

- **三元组**矩阵的转置，经历了三个步骤：

  - 矩阵的行数 n 和列数 m 的值交换；

  - 将三元组中的i和j调换；

  - 转换之后的表同样按照行序（置换前的列序）为主序，进行排序；

    (例:三元组的转置很简单,只需交换i,j的值,						答案:错误)

### 排序

```c++
///希尔排序
for(int id=n>>1;id>=1;id<<=1){
    for(int i=1;i<=n;i++)
    if(a[i]>a[i+id]){
        a[0]=a[i+id];
        for(int j=i-id;j>0&&a[0]<a[j];j-=id){
            a[j+id]=a[j];
        }
        a[j+id]=a[0];
    }
}
```

```r
///冒泡排序
void swap(int a,int b){///O(0) swap
    a=a+b;
    b=a-b;
    a=a-b;
}

for(int i=n;i>=1;i--){
    flag=false;
    for(int j=n;j>i;j--) if(a[i]<a[i-1]) swap(a[i],a[i-1]),flag=true;
    if(!flag) return;
}

///简单选择排序
for(int i=0;i<n-1;i++){
    int min=i;
    int j;
    for(j=i+1;j<n;j++){
        if(a[min]>a[j]) min=j;
    }
    if(min!=i) swap(a[j],a[min])
}
///注:简单选择排序和冒泡排序有相似,要区分
///区别在于:选择排序每次都会把最小的和当前这趟首元素交换位置,
```

```c++
///快排
int l=1,r=n;
int Partition(int a[],int l,int r){
    int pivot=a[l];
	while(l<r){
        while(l<r&&a[r]>=pivot) r--;
        a[l]=a[r];
        while(l<r&&a[l]<=pivot) l++;
        a[r]=a[l];
    }
    a[l]=pivot;
    return low;
}

void Qsort(int a[],int l,int r){
    if(l,r){
    int pivotpos=Partition(a,lr);
    Qsort(a,l,pivotpos);
    Qsort(a,pivotpos+1,r);
    }
}
```

```c++
///堆排序(大根堆)

void stiffDown(int a[],int k,int len){
    int a[0]=a[k];
    fot(int ch=k<<1;ch<=len;ch<<=2){
        if(ch<len&&a[ch+1]>a[ch]) ch++;
        if(a[0]>=a[ch]) break;
        a[k]=a[ch];
        k=ch;
    }
    a[k]=a[0];
}

void stiffUp(int a[],int k,int len){
    int a[0]=a[k];
	for(int pa=k>>1;pa>0;pa>>=1){
        if(a[0]>a[pa]) a[k]=a[pa]; else break;
        k=pa;
    }
    a[k]=a[0];
}

void buildMaxHeap(int a[],int len){
    for(int i=(len>>1);i>0;i--) stiffDown(a,i,len);
}

void deleteTop(int a[]){
    swap(a[1],a[len]);
    a[len--]=-1;
    stiffDown(a,1,len);
}

void insert(int a[],int k){
    a[len++]=k;
    stiffUp(a,len);
}

void heapSort(int a[],int len){
    buildMaxHeap(a,len);
    for(int i=len;i>0;i--){
        swap(a[1],a[i]);
        stiffDown(a,1,i-1)
    } 
}
```

```c++
///归并排序
void Merge(int a[],int l,int r){
    for(int i=l;i<=r;i++) B[i]=A[i];
    int mid=(l+r)>>1;
    int i;
    for(int i=0,k=l,j=mid+1;i<=mid&&j<=r;k++){
        if(B[i]<=B[j]) A[k]=B[i++];
        else A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=r) A[k++]=B[j]++;
}

void mergeSort(int a[],int l,int r){
    int mid=(l+r)>>1;
    mergeSort(a,l,mid);
    mergeSort(a,mid+1,r);
    merge(a,l,r);
}
```

- 基数排序

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000636226.png" alt="1570000636226" style="zoom: 67%;" />

各种内排序的比较

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000696976.png" alt="1570000696976" style="zoom: 67%;" />

​			**算法复杂度**与初始状态无关的有：**选择排序、堆排序、归并排序、基数排序。**

​			元素总**比较次数**与初始状态无关的有：**选择排序**、**基数排序**  **折半插入排序**。

​			元素总**移动次数**与初始状态无关的有：**归并排序**、**基数排序**。

- 外部排序

  	多路归并

![1570001947191](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570001947191.png)
**注**：理论上，增大躺数可以减少归并次数；归并趟数=$ceil(log_mr)$

​	  

​		败者树(消除m路归并,增大归并路数的影响)

![1570002634614](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570002634614.png)
			置换-选择排序

![1570003607744](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003607744.png)
![1570003716126](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003716126.png)
![1570003755469](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003755469.png)



​		最佳归并树(多路汉夫曼树):掌握不能构成严格哈夫曼树时如何新增结点

![1570004972627](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570004972627.png)

## 网络

### 计算机网络体系结构

- 计算机网络的分类

| 按分布范围划分           | 按传输技术划分   | 按使用者划分  | 按交换技术划分             | 按拓扑结构划分      | 按传输介质 |
| ------------------------ | ---------------- | ------------- | -------------------------- | ------------------- | ---------- |
| 广域网、域域网 局域网... | 广播网、点对点网 | 公用网 专用网 | 电路交换 报文交换 分组交换 | 星形 环形 总线 网状 | 蓝牙..     |

- 总时延=发送时延(**传输时延**)+**传播时延**+处理时延+排队时延
  - 发送时延=分组长度/信道宽度
  - 传播时延:信道长度/电磁波在信道上的传播速度
  - 一般题目未提及，忽略处理时延和排队时延
- 时延带宽积=第一个比特到达终点时，发送端已经发送的比特数。直观上=传播时延*信道带宽
- 数据帧的抽象结构
  - 服务数据单元(SDU)：完成要求功能而应传送的数据
  - 协议控制信息(PCI)：控制协议操作的信息
  - 协议数据单元(PDU):**对等层之间**传送数据的的单位
  - 三者间的挂你:n-PCI+n-SDU=n-PDU=(n-1)-SDU
- OSI与TCP/IP的比较

| OSI        | TCP/IP                              | 协议栈                         |
| ---------- | ----------------------------------- | ------------------------------ |
| 应用层     | 应用层                              | telnet\ftp\dns\smtp\http       |
| 表示层     | 应用层                              | --------                       |
| 会话层     | 应用层                              | --------                       |
| 传输层     | 传输层                              | TCP\UDP                        |
| 网络层     | 网际层                              | IP\IPX\OSPF\ICMP\IGMP\ARP\RARP |
| 数据链路层 | 网络接口层                          | SDLC\HDLC\PPP\STP              |
| 物理层     | 网络接口层(网络接口$\to{}$物理接口) | EIA\CCITT                      |

**注**：OSI**网络层**支持无连接与面向连接通信，但在**传输层**只有面向连接

​		TCP/IP**网络层**只有无连接通信，**传输层**支持无连接和面向连接(认为可靠性是端到端)

### 物理层

- 码元:一个固定时长的**信号波形**,数字通信中数字信号的**计量单位**；1码元可以携带多比特的信息量

- 数据通信系统；信原、信道、信宿

  [^注]: 信道与电路不等同。信道是线路的逻辑部件

- 码元传输速率:单位时间内传送码元的个数,单位**波特**=1码元/s

  [^注]: 波特和比特是不同概念,二进制码元可以看作1bit，此时的速率叫**信息传输速率**;若一码元携带nbit信息,M baud的码元的传输速率对应的信息传输率=M*nbit/s

- 奈奎斯特定理:理想状况(无干扰)的信道中,极限码元传输率为2W baud(W:理想低通信道的带宽,单位Hz)

  [^注]: 若有V种不同的码元(离散电平数目为V),则理想低通信道下的数据传输率=$2Wlog_2V$.(bit/s)

  - 结论:
    - 在任何信道中,码元的传输速率是有上限的 
    - 信道的频带越宽可用更高的速率进行码元的有效传输
    - 给出了**码元传输速率**的限制,没有对**信息传输速率**限制(一个码元可以对应多个二进制)

- 香农定理:**带宽受限**且**有干扰**的极限数据传输速率;信道极限数据传输速率=$Wlog_2(1+S/N)$

  [^注]: W位信道带宽,S为信道所传输信号的平均功率,信噪比=$10log_{10}(S/N) 单位dB$

  - 结论:
    - 信道带宽越大或信噪比越大,传输率越大
    - 信噪比和带宽确定,传输率**上限**确定
    - 只要信息的传输率低于信道的极限传输率,就一定有办法来实现无差别传输

- 常见编码方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570192543222.png" alt="1570192543222" style="zoom:67%;" />

| 非归零码                              | 曼彻斯特编码   | 差分曼彻斯特      | 4B/5B |
| ------------------------------------- | -------------- | ----------------- | ----- |
| 无检错功能,无法判断一个码元的开始结束 | 以太网编码方式 | 自同步 抗干扰性好 |       |

- 调制为模拟信号

| 幅移键控(ASK)                             | 频移键控(FSK)                        | 相移键控(PSK)                                   | 正交调制                                                     |
| ----------------------------------------- | ------------------------------------ | ----------------------------------------------- | ------------------------------------------------------------ |
| 通过振幅来控制信号；比较容易实现,抗干扰差 | 通过频率来控制信号;容易实现,抗干扰强 | 通过相位来控制信号,分**绝对调相**和**相对调相** | 频率相同前提下,结合ASK和PSK；设波特率=B,m个相位,n种振幅,数据传输率=$Blog_2(m*n)$(bit/s) |

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570193187440.png" alt="1570193187440" style="zoom:67%;" />

- 采样定理
  - **抽样**是指对模拟信号就行周期性扫描,把时间上**连续的信号**变成时间上**离散的信号**，<u>当抽样的频率大于或等于模拟数据的频带带宽的**两倍**时,所得的离散信号可以无失真地代表被抽样地模拟数据</u>
  - **量化**是指把抽样取得的电平幅值按一定分级标度转化位对应的数字值，并取整
  - **编码**是把量化结果转换为与之对应地二进制编码
- 虚电路与数据报的比较

 <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570200346727.png" alt="1570200346727" style="zoom:67%;" />

- 各层设备

|          | 网络层 | 数据链路层  | 物理层                         |
| -------- | ------ | ----------- | ------------------------------ |
| 主要设备 | 路由器 | 交换机 网桥 | 中继器(转发器):集线器(半双工): |

[^注]: 放大器放大的使<u>模拟信号</u>,中继器放大的是<u>数字信号</u>；中继器无存储转发功能,因此<u>不能连接协议不同的网段</u>
[^注]: 传输媒体不是物理层

- 各设备能否隔离广播域、冲突域

<img src="https://img-blog.csdn.net/20170107145830295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°" style="zoom: 80%;" />

### 数据链路层

- 组帧

| 字符计数法                           | 首位定界符法              | 比特填充法                                      |
| ------------------------------------ | ------------------------- | ----------------------------------------------- |
| 帧头部使用一个计数字段来表明内字符数 | 用ASCII码来定界一帧的开始 | 01111110(发送方:信息位遇到5个连续的1,自动插入0) |

- 滑动窗口流量控制

  - 发送窗口控制发送端的发送速率

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570367309301.png" alt="1570367309301" style="zoom:67%;" />

  [^注]: $W_T$表示还没有<u>收到对方确认信息</u>的情况下发送方最对可以发送多少个数据帧；接收方控制发送方发送数据的速率

  - 数据链路层和传输层滑动窗口的差别

    | 传输层滑动窗口             | 数据链路层滑动窗口                                         |
    | -------------------------- | ---------------------------------------------------------- |
    | 端到端用户之间             | 点对点相邻节点                                             |
    | (拥塞)窗口大小可以动态变化 | 窗口不可动态变化;<u>当接收窗口为1时,可保证帧的有序到达</u> |
    | 发送最小单位:字节          | 发送最小单位:数据帧                                        |

  - 停止-等待流量控制：发送(接收方)方每发送(接收)一帧，都要等接收方的应答信号才能发送下一帧；<u>如果接收方不反馈应答信号则发送方必须一直等待</u>

  - 自动重传请求(ARQ Auto Repeat Request):

### 网络层

- ICMP(Internet Control Message Protocol)

  - <u>用于目标主机或目标主机路径上的路由器向源主机报告差错和异常情况</u>，共有以下五种情况

    - 终点不可达:当路由器或主机不能交付数据报时,向源点发送不可达报文
    - 源点抑制:由于**拥塞**而丢弃数据时,发送源点抑制报文
    - 时间超过:收到生存时间(TTL)=0的数据报时,除了丢弃该报文外,还要发送时间超过报文
    - 参数问题:当收到的数据报的首部中有的字段值不正确时,丢弃该报文,并发送参数问题报文
    - 改变路由(重定向):让主机下次将数据报发送给另外的路由器(可通过更好的路由)

  - 不应该发送ICMP差错报告的几种情况

    - 对ICMP差错报文

    - 对第一个分片的数据报片的所有后续数据报片都不发送

    - 对具有<u>组播地址</u>的数据报

    - 对具有特殊地址(如0.0.0.0 127.0.0.0)的数据报

      | PING                   | Tracert          |
      | ---------------------- | ---------------- |
      | ICMP会送请求和回答报文 | ICMP时间超过报文 |
      | 应用层                 | 网络层           |

    

