# 408遗忘知识点总结

## 组原

### 第一章

- 第一台电子数字计算机:ENIAC

  | 单指令和单数据流系统SISD | 单指令多数据流系统SIMD | 多指令单数据流系统MISD | 多指令多数据流系统MIMD |
  | ------------------------ | ---------------------- | ---------------------- | ---------------------- |
  | 冯诺依曼体系结构         | 阵列处理器和向量处理器 | ________               | 多处理器和多计算机系统 |

- 冯诺依曼机的特点(SISD)

  ![1569841926106](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569841926106.png)

- 累加器 :是一种**寄存器**，用来储存计算产生的中间结果。

- 一个汉字通常占2B

- 汉字字库中存放汉字字模码

-  汉字内码:又称“汉字ASCII码”，简称“内码”，指计算机内部存储，处理加工和传输汉字时所用的由0和1符号组成的代码 

- 完整的计算机系统应包括<u>硬件系统和软件系统</u>

- 机器语言和<u>汇编语言</u>都是面向机器的语言

- 程序是<u>数据和指令</u>的有序集合

### 数据的表示和运算

- 校验码
  - 码距:任意两个合法码之间最少变化的二进制位数;码距>=2，开始具备检错能力;码距越大，检\纠错能力越强,纠错能力>=检错能力
- 奇偶校验码

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279195718.png" alt="1570279195718" style="zoom:80%;" />

- 海明码(<u>发现双比特错,纠正单笔比特错</u>):表示法方法(n,k) n位编码,数据位k位

  - L-1=D+C (D>=C) L:最小码距 D:检错位数 C:纠错位数

    [^注]: 海明码检错d位,码距至少d+1(令上式D=0)  纠错d位,码距至少2d+1(令D=C=d)

- 海明码求解步骤(练习参见袁书习题)

  ![1570279987658](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279987658.png)

![1570279816177](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279816177.png)

[^注]: 校验实际上是在上(4)的基础上左右亦或P1,若无措,自然结果=0

- 例2

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281565897.png" alt="1570281565897" style="zoom:70%;" />

  

- 无符号数和带符号数各种比较运算的逻辑判断式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570546936251.png" alt="1570546936251" style="zoom:67%;" />

[^注]: 无符号数相减时一般不考虑SF和OF 带符号相减时,一般不考虑CF;借位\进位相对于真值来说

- 循环冗余码(CRC)

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281702819.png" alt="1570281702819" style="zoom: 80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281737694.png" alt="1570281737694" style="zoom:80%;" />

- 强制转化(具体参考CSAPP)

| int$\to$float            | int/float$\to$double | double$\to$float  | floatdouble$\to$int |
| ------------------------ | -------------------- | ----------------- | ------------------- |
| 不会溢出,但会<u>舍入</u> | 能够保留精确的数值   | 可能溢出,可能舍入 | 向零舍入            |

- 运算(简单的不恢复余数法,记得日后补上)

  [^注]: 无符号数的减法和有符号一样,只是对于最终结果解释不同;无符号数的加法进位是在外边如10000110+11110110=(1)01111100
  
- 各编码的取值范围

  - 浮点数

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570796716639.png" alt="1570796716639" style="zoom:80%;" />

  - 定点数

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570796784899.png" alt="1570796784899" style="zoom:67%;" />

- 溢出的判别法

  - 双符号位  		<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958123808.png" alt="1570958123808" style="zoom:67%;" />
  - 单符号位![1570958177268](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958177268.png)

- 浮点数

  - 规格化<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958748114.png" alt="1570958748114" style="zoom:67%;" />![1570958939196](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958939196.png)

    - IEEE754												<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570959039816.png" alt="1570959039816" style="zoom:67%;" /><img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570959175877.png" alt="1570959175877" style="zoom:80%;" />

      [^注]: 计算的时候记得阶码要减去偏置值或加上偏置值

      [^注]:尾数部
  [^]:分为原码表示,位数从右(低)往左(高)写,高位不足补零
      [^注]:阶码全1,尾数全0,表示无穷大,若此时尾数不为全0 表示NaN(非法值);   阶码全0,表示非规格化数，注意非规格化数的指数为-126而不是-127

- 加法器

  | 行波进位加法器(串行进位加法器) | 先行进位加法器                                               | 成组先行进位                                                 |
  | ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | n个全加器按照串行方式连接实现  | 引入`进位生成`和`进位传递`两个辅助函数,是恶的各个吉纳维间独立\并行产生 | 将数据分成若干组,在组内除了并行生成组内各位向前的进位外,同时还通过`组进位生成`和`和组进位传递`实现 |

  - 74181(4位并行加法器):能执行416位算术运算和逻辑运算,可工作在正/负逻辑操作下;组内(片内)并行,组间(片间)串行
  
- 舍入

### 存储系统

- 存储元:存放一个二进制位的物理器件
- 存储单元:存放一个**机器字**的所有存储元;地址码相同的多个**存储元**构成存储单元
- 双端口ram:注意是<u>同地址</u>的操作才会引起冲突(选择题可能忽略掉这个,造成错误选项)
- RAM:<u>随机存储器</u> ROM:<u>只读存储器</u>  二者存取方式均为<u>随机存取</u>
- 串行访问存储器:如磁带、光盘(CD-ROM)等。包括ian<u>顺序存取存储器</u>和<u>直接存取存储器</u>:先寻找整个存储器中的某个小区域(如磁盘的磁道),再再小区域内顺序查找 
- SRAM DRAM各自得特点

![1569747278920](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569747278920.png)

[^注]: dram采用<u>地址复用技术,</u>，计算引脚时，地址线数结果除2

- 字位同时扩展:先位组成一行,然后按字变成多行.<u>此时各芯片连接地址先得方式相同,但连接数据线得方式不同</u>

- 主存容量=$2^{地址线数}(编制范围)*字长$[^常说的64位机器指的是数据线的根数或是指令的位数]

- 刷新方式

  | 集中刷新                                                     | 分散刷新                                                     | 异步刷新                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
  | 固定的时间内对所有行进行刷新;停止存储器的读写操作,产生<u>死时间(死区)</u> | <u>每一行</u>的刷新分散到各个工作周期中;前半部分读写,后半部分刷新 | 结合前两种,**缩短**死时间,充分利用刷新间隔 |
  |                                                              |                                                              |                                            |

  - 刷新的相关计算      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571225259141.png" alt="1571225259141" style="zoom:67%;" />

  [^注]: 缩短字数,增加位数可以减少刷新操作，但Dram一般行列相等

- ROM的分类

| 掩模式只读存储器MROM                | 一次可编程只读存储器PROM                       | 可擦除可编程只读存储器EPROM                    | 闪存FLASH      | 固态存储SSD |
| ----------------------------------- | ---------------------------------------------- | ---------------------------------------------- | -------------- | ----------- |
| 生产过程直接写入,写入后无法改变内容 | 允许用户写入自己的程序,一旦写入后,内容无法改变 | 可对其内容多次改写<br />又分紫外线擦除、电擦除 | 随机访问<br /> |             |

[^注]: 一般存储体的读写速度不一致,读速度快于写速度

- 三种映射方式得地址结构

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748348509.png" alt="1569748348509" style="zoom:80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748562645.png" alt="1569748562645" style="zoom:80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748592130.png" alt="1569748592130" style="zoom:80%;" />

[^注]: 真题中出现过这样的组相联:例如4行二路组相联,主存地址0-1 4-5 8-9映射到0组；
[^注]:做题时注意题目给的时`主存块号`还是`主存地址`,主存地址则对应上方,若时块号,则需要mod块数(组数)

- cache行的示意图(计算cache容量时用,<u>注意与地址结构区分</u>)<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571301459375.png" alt="1571301459375" style="zoom:67%;" />
  
  [^注]: 直接映射的电路的设计最为简单,全相联的最复杂;cache与主存的映射由硬件完成
  [^注]: 看清题目问的是求`cache数据区`的大小(行大小×行数)还是`(数据)cache的大小` (1+tag+行大小)×行数 ​;还是求`地址映射表`的大小(tag+1bit)×行数)
  [^注]:若题目中包括写回位(1bit) LRU位=$log_2{每组的行数}$
  
- 有关计算![1571214759080](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571214759080.png)
  
  假设系统有多个cache,标记位实际上就是<u>cache的编号</u>,因此主存容量是cache的4096倍等价于有4096个cache等价于标记位=12位;地址映射表即标记位+有效位=13bit 
  
- 命中率

  [^注]: 若题目中说了指令cache 与数据cache分离,问算命中率则应对应算指令命中率或数据命中率(如14真题T45)

- cache的写策略

  | 写命中         |                                                              | 写不命中   |                                                     |
  | -------------- | ------------------------------------------------------------ | ---------- | --------------------------------------------------- |
  | 全写法(直泻法) | 将数据同时写入cache和主存,当某一块需要替换时只将新调入的块直接覆盖<br />写缓冲:cache和主存之间,CPU同时写数据到Cache和缓冲中,写缓冲再控制将内容写入主存 | 写分配法   | 加载主存中的块到cache中,然后更新这个cache块(局部性) |
  | 写回法         | 只修改Cache的内容,只有当此块被换出时才写回主存<br /><u>采用这种方式时每个cache行需要一位脏位</u>(重点,计算Cache容量时常考) | 非写分配法 | 只写入主存不进行调块                                |

  [^注]: 写分配法+写回法,非写分配+全写法

- 有关cache的一些指标计算<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571831274701.png" alt="1571831274701" style="zoom:67%;" />

  补充:系统的效率=$T_{cache}/T_{average}=t/1.2t$

  若采用先访问cache再访问主存的方式 $T_{average}=T_{cache}+(1-hit)*T_m=0.95t+0.05*6t=1.25t$ 

### 指令系统

- 指令系统:**机器指令**的集合

- 指令的基本格式
  - 二地址指令<u>:目的操作数</u>用于保存本次<u>运算结果</u>(大题中出现二地址指令,默认知道此条)
- 常见的<u>数据寻址</u>方式

| <font size=2>隐含寻址</font>                             | <font size=2>立即数..</font>                      | <font size=2>直接..</font> | <font size=2>间接..</font> |   <font size=2>寄存器..</font>   | <font size=2>寄存器间接.. </font> | <font size=2>相对..</font> | <font size=2>基址</font>                                | <font size=2>变址</font>                                | <font size=2>堆栈</font> |
| ----------------------------------------------------------- | ------------------------------------------------------ | -------------------------- | ----------------------------- | :------------: | -------------- | :--------------: | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------- |
| <font size=2>指令中隐含操作数地址</font>                    |OP=A                                                   | EA=A                       | <font size=2>EA=(A)</font>   | EA=$R_A$    | <font size=2>EA=($R_A$)</font> | EA=PC+(A)       | EA=(BR)+A                                                 | EA=(IX)+A                                                    | <font size=2>硬堆栈 (寄存器堆栈)\软堆栈</font> |
| <font size=2>单地址指令只给出第一操作数地址,<u>ACC</u>作为第二操作数地址</font> | <font size=2>数据采用**补码**存放;执行不访问主存,<br />执行时间最短</font> | <font size=2>指令地址位数决定了寻址范围</font> | <font size=2>可扩大寻址范围,但需要多次访存</font> | <font size=2>执行阶段不访存</font> | <font size=2>同间接寻址可扩大范围,但查找速度比间接快 </font> | <font size=2>广泛用于转移指令</font> | <font size=2>基址寄存器可以是通用寄存器也可以是专用寄存器;<br />用户可以决定哪个寄存器,但<u>内容由操作系统决定</u>(<u>面向操作系统</u>)</font> | <font size=2>变址寄存器<u>面向用户</u><br />可用变址寄存器(<u>专用</u>)也可用通用寄存器<br />常用于<u>数组处理</u></font> | <font size=2>自动完成对SP的增量减量操作</font> |

[^注]: 数据通路:各个功能部件通过数据总线连接形成的<u>数据传输路径</u>;数据总线是承载数据的<u>媒介</u>
[^注]: 数据寻址比指令寻址复杂 指令寻址一般在内存,数据寻址还可能在寄存器,I/O端口

- 从处理器设计的角度,定长指令要比变长指令好

- 定长指令的有关计算
  - 首先从地址数目最多的出发,用指令字长减去地址位数得到n,则该类型指令还剩$2^n-k_2$
  - 然后左移一个地址码的位数(相当于地址码数-1),此时得到的是一地址指令的总数目，重复第一步
    
    - 例题![image-20191026162846568](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026162846568.png) <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026163242405.png" alt="image-20191026163242405" style="zoom:67%;" />
    
      [^注]:这里按字节编址,字长应该是8的倍数 答案A

- 转移指令(程序控制指令)和调用(转子)指令的区别

  转移指令分条件转移(分支指令)和无条件转移,<u>转移后不再返回来执行</u>

  调用(转子)指令:除了转移外,转移后还要保存返回地址
  
- 问指令是否有数据相关的题:画出指令流水过程图,

  - 注意若指令间存在数据相关则只有在上一条相关指令的WB(写回)后才可以执行ID(指令译码)

  - 下一条IF和上一条的ID对齐

    [^注]: 这种题目都先观察,如果复杂(题目没有要求)的就在草稿纸上作草图
  
- 超标量流水线                                                                                            <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191031155913030.png" alt="image-20191031155913030" style="zoom: 50%;" />

- 超流水                                                                                                             <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191031155959707.png" alt="image-20191031155959707" style="zoom:50%;" />
- <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191031160059393.png" alt="image-20191031160059393" style="zoom:57%;" />

### 中央处理器

- CPU总是在执行指令不会停下来,即使在等待IO进程过程中也在执行指令查询IO设备
- CPU主频越高运算速度越快(错)

- 微指令编码方式

  - 水平型(并行性好，但指令长,不利于边写微程序)

    - 直接编码(无需译码):<u>每一位</u>代表一个微命令

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570690837701.png" alt="1570690837701" style="zoom:67%;" />

    - 字段直接编码(用二进制编码操作控制端)

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570691112841.png" alt="1570691112841" style="zoom:67%;" />

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570691026083.png" alt="1570691026083" style="zoom:80%;" />

    - 字段间接编码:一个字段中的某些微命令需要另一个字段中的某些微命令来解释

  - 垂直型(与水平型相对,类似机器指令操作码)<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570692044203.png" alt="1570692044203" style="zoom: 80%;" />
    

- 微程序、微命令、微指令、微操作的关系

| 微指令           | 微操作                                  | 微命令                                                       | 微程序                  |
| ---------------- | --------------------------------------- | ------------------------------------------------------------ | ----------------------- |
| 若干微命令的集合 | 执行部件接受<u>微命令</u>后所执行的操作 | 控制部件通过控制线向执行部件发出各种控制命令;<u>控制序列的最小单位</u> | <u>微指令</u>的有序集合 |

[^注1]:存放微指令的控制存储器单元成为<u>微地址</u> (控存用来存放微程序,用ROM实现,在CPU内部);
[^注2]:采用微程序控制器的处理器叫做微处理器,<u>这句话是不对的</u>
[^注3]:微命令与微操作这两个概念,不是微程序控制器的专有概念 

- 微周期:从控存中<u>读取</u>一条微指令并<u>执行</u>相应微操作的时间(与指令周期类似)

- 控存容量的计算:$2^n*b$    n为下地址字段的位数,b为微指令的位数(存疑)

- 机器周期和时钟周期的区别

  | 时钟周期                                                     | 机器周期(CPU周期)                                            |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | CPU的晶振的工作频率的倒数，是**计算机中最基本的、最小的时间单位** | CPU完成一项基本任务的时间,如指令周期被分成多个机器周期(IF ID...) |

- 组合逻辑控制器与微程序控制器的区别

  |                | 控存/主存(CM/MM)          | MAR\CMAR                              | IR\μIR或CMDR                     |
  | -------------- | ------------------------- | ------------------------------------- | -------------------------------- |
  | 组合逻辑控制器 | MM:存放程序和数据,RAM实现 | MAR:存放主存的读写地址<br />          | IR:存放从主存读出的指令          |
  | 微程序控制器   | CM:只存放微程序,ROM实现   | CMAR:存放控存读/写<u>微指令的地址</u> | μIR或CMDR:存放从控存读出的微指令 |

- 微程序控制器的工作流程<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026183440136.png" alt="image-20191026183440136" style="zoom:67%;" />
  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026183520291.png" alt="image-20191026183520291" style="zoom:67%;" />
  
- CISC与RISC的判断:1、load指令访存 2、指令长度是否唯一(未完待续)

### 总线

- 这章所讲的总线都是系统总线;[^注]CPU中内总线是<u>(一个)同一部件</u>,系统总线是（多个)<u>不同部件</u>

- 总线的性能指标
  - 总线的传输周期:一次总线操作所需的时间(包括申请\寻址\传输\结束),简称**总线周期**
  - 总线时钟周期:机器的时钟周期
  - 总线的工作频率:<u>总线周期</u>的倒数
  - 总线宽度(总线位宽):总线上同时能够传输的数据位数,通常指数据总线的根数
  - 总线带宽:即总线数据的传输率

- 总线事务:是在一个<u>总线周期</u>中发生的一系列活动。典型的总线事务包括请求操作、裁决操作、地址传输、数据传输和总线释放

- 按功能划分总线

| 片内总线        | 系统总线                                                     | 通信总线                                                 |
| --------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| CPU芯片内的总系 | 按传输内容分可分为:<br />数据总线(双向):传输各功能部件的<u>信息(如除了地址和信号外的所有信息）</u><br />地址总线(单向):指出主存单元或i/o地址<br />控制总线:传输<u>控制信号、命令、总线(中断)请求\允许</u> | 计算机系统与其他系统之间信息传送的总线,如<u>握手信号</u> |

- 总线的分类

| 系统总线 | 局部总线               | 设备总线 | 其他                                     |
| -------- | ---------------------- | -------- | ---------------------------------------- |
| ISA      | VESA\PCI(即插即用)\AGP | USB      | EISA\PCI-EXPRESS\RS-232C\PCMCIA\IDE\SATA |

[^注]: USB\RS232\PCI-EXPRESS为串行总线,每次只能传输1位数据

- 突发传送(存储器):只需传送开始时给出数据块的首地址,然后连续传送多个数据，能实现一个时钟传送多个数据(可理解为多个单元数据当作一个单元数据传送)

  [^注]: 计算时$T_{总线}=T_{传递址}+T_{连续数据}$，一般传地址也是一个总线周期

- 总线传输的四个阶段:1.申请分配阶段 2.寻址阶段 3.传输阶段 4.结束阶段

- 定时方式

  - 同步定时方式:统一时钟信号;<u>用于总线长度较短及总线所接部件的存取时间比较接近的系统</u>

  - 异步定时方式:没有统一时钟,也没有固定时间间隔;总线长度可变,保证两个工作速度相差很大的部件进行可靠通信

    - 不互锁方式

    - 半互锁方式:主设备发出请求后,需等待从设备的回答后才撤销请求信号

    - 全互锁方式:主设备"请求"后需等待从设备"回答"才撤销“请求”;从设备"回答"后,需等待主设备"请求"撤销后,才能撤销"回答"

      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191101173623982.png" alt="image-20191101173623982" style="zoom:67%;" />

      [^注]: 异步通信规定传输的数据格式由`起始位`、`数据位`、`奇偶校验位`和`停止位`组成

### I/O系统

- IO软件系统的层次(由上到下):用户级IO软件->设备无关的操作系统软件->设备驱动程序->中断处理程序->硬件

- IO端口及其编址

  |                        |                                                              |
  | ---------------------- | ------------------------------------------------------------ |
  | 统一编址(存储映射方式) | 把IO端口当作存储器单元进行地址分配,CPU不需要设置转么的IO指令 |
  | 独立编址(I/0映射方式)  | IO端口地址与存储器地址无关,需要设置专门的访问端口            |

- IO端口类型:数据端口、控制端口、状态端口(与三大总线区分,无"地址端口"所以不传送地址)

- `中断响应优先级`和`中断处理优先级`的区别:前者由<u>硬件排队线路或中断查询的查询顺序</u>决定的,不可动态改变;后者可通过设置中断屏蔽字来改变

- 总线仲裁

  - 集中总线仲裁

    BR:总线请求 BS总线忙 BG:总线允许 n:设备个数

    |          | 链式查询                         | 计数器定时查询                                               | 独立请求              |
    | -------- | -------------------------------- | ------------------------------------------------------------ | --------------------- |
    | 控制线数 | 3(BS:1 BR:1 BG:1)                | $\lceil log_2n\rceil$+2(BR:1 BS:1 BG: $\lceil log_2n\rceil$) | 2n+1(BR:n BG:n BS:1)  |
    | 特点     | 优先级固定,扩充容易              | 优先级灵活                                                   | 响应速度块,优先级灵活 |
    | 缺点     | 效率低;优先级不灵活,电路故障敏感 | 控制线多,控制复杂                                            | 控制线多,控制复杂     |

    [^注]: 链式查询总线响应信号串行传输,依次查询，像链条一样，所以每个各一根;
    [^]:     计数器查询,将每个计数器按二进制编号,n个设备,只需$log_2n$位,对应总线允许;独立请求每个设备独立占用一根BG BR;BS都是公用

  - 分布式仲裁:不需要中央仲裁器,每个潜在的主模块都有自己的仲裁号和仲裁器

- (CPU)内中断(CPU) 外中断

| 内中断(软中断)                                               | 外中断(硬中断)                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可以在指令执行期间产生和处理中断信号,指CPU内产生的中断<br /><u>同步</u><u>,<br />分为陷阱\故障\终止</u><br />一般由指令引起,如:缺页中断\算术溢出\除数为...<br />可能终止当前执行的程序也可能返回 | 在每条指令的结束时响应,CPU外产生的中断<br><u>异步</u><br />一般由外部引起,,不由指令引起如:IO中断 |

[^注]: 中断判优中一般硬件故障>软中断>非屏蔽>屏蔽;DMA>IO传送的中断请求
[^注]: 中断发生时,操纵系统保存所有`通用寄存器`的内容(包括PSW),可能设置`TLB和MMU和页表`,CPU保存PC

- 中断的处理流程(熟背)

| 单重中断                                     | 多重中断(中断嵌套)                           |
| -------------------------------------------- | -------------------------------------------- |
| 关中断**(中断隐指令(硬件))**(向下到保护现场) | 关中断(**中断隐指令((硬件))**向下到保护现场) |
| 保存断点(pc)                                 | 保存断点(pc)                                 |
| 送中断向量                                   | 送中断向量                                   |
| 保护现场**(中断服务程序)**(向下都是)         | 保护现场和屏蔽字**(中断服务程序)**(向下都是) |
| ---------                                    | 开中断                                       |
| 执行中断服务程序                             | 执行中断服务程序                             |
| ----------                                   | 关中断                                       |
| 恢复现场                                     | 恢复现场和屏蔽字                             |
| 开中断                                       | 开中断                                       |
| 中断返回                                     | 中断返回                                     |

[^注1]: 中断隐指令不是一条真正的指令,没有操作码
[^注2]: 中断向量:中服务程序的入口地址;中断向量地址:中断向量的地址(程序入口地址的地址)
[^注3]: 硬件产生中断类型号,中断类型号指出中断向量地址

- DMA(Direct Memory Access)的有关概念

  - CPU在一次<u>总线操作结束</u>时,一旦发现DMA请求,就立即释放总线

  - 周期挪用:当DMA与CPU冲突时,CPU挪出一个**主存存储周期**给DMA访问内存

  - DMA传送流程图

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570694175405.png" alt="1570694175405" style="zoom:67%;" />

- 通道控制方式:通道指专门负责IO的<u>处理机</u>

  - 与一般处理机的区别:1.通道指令类型单一 2.没有自己的内存 ,<u>通道与CPU共享内存</u>
  - 与DMA的区别:通道拥有更高的自主权,数据块大小、传输的内存位置，都可以自己决定
  - 

- 假脱机技术SPOOLING:利用专门的外围控制机,将低速IO设备的数据传送到高速磁盘上,或者相反<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571744976961.png" alt="1571744976961" style="zoom:67%;" />

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571745116067.png" alt="1571745116067" style="zoom:67%;" />	

- 廉价磁盘阵列(RAID)

| RAID0 | 无冗余码和无检验码       |
| ----- | ------------------------ |
| RAID1 | 镜像磁盘阵列             |
| RAID2 | 采用海明码               |
| RAID3 | 采用位交叉奇偶校验       |
| RAID4 | 采用块交叉奇偶校验       |
| RAID5 | 采用无独立校验的奇偶校验 |

- (了解)条带化strip:是把连续的数据分割成相同大小的数据块，把每段数据分别写入到阵列中的不同磁盘上的方法。简单的说，条带是一种将多个磁盘驱动器合并为一个卷的方法。 许多情况下，这是通过硬件控制器来完成的
- 磁盘存储器
  - 磁盘读写的最小单位:扇区(块)，存储单位:B
  
  - 磁盘所有磁道记录的信息量相等
  
  - 平均数据数据传输率(以一个磁道的传输率为例)=一个磁道的容量/旋转一圈时间
  
  - <u>平均存取时间(重点)</u>:平均寻道时间+旋转时间(旋转一圈周期/2的时间)+传输时间(有时忽略传输时间)
  
    [^注]: 寻道时间的计算,有时题目给的可能是`道间移动的时间`,这时候平均寻道时间=(0+道数*道间移动时间)/2
  
    ![1571908072189](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571908072189.png)
    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571908103367.png" alt="1571908103367" style="zoom:67%;" />
  
  - 

### 附录:

- 计算机性能的一些指标

| MIPS(Million Instructions Per Second) | CPI                                                          | MFLOPS                       |
| ------------------------------------- | ------------------------------------------------------------ | ---------------------------- |
| 每秒执行对少百万条指令                | 平均每条指令的时钟周期数<br />IPC:CPI的倒数,每个时钟周期执行多少条指令 | 每秒执行多少百万条浮点数运算 |

​     主频:即CPU的时钟频率  

​     吞吐率:CPU单位时间处理的任务数 

​     响应时间:指的是从请求端发起请求开始，到请求端接收到服务器端的返回结束，这个过程所耗费的时间 

- 关于大\小端存储器编址的个人理解
  - 编译程序时,机器顺序翻译代码,对于如3FH这样的数必然是先翻译3 后F,也即默认情况下先对3分配地址,再F分配地址,所以3对应内存的低地址,F对应内存的高地址(<u>**大端方式或称高字节低地址**</u>).而**小端方式**则是按照**低字节低地址**;感性上理解就是大端方式存储模式与我直觉上相同,而小端方式与直觉相反
- j

## OS

### 概述

- 批处理系统
  - 单道批处理系统:系统对作业的处理成批进行,但内存只保持一道作业
  - 多道批处理系统:(多道程序设计)允许多个程序同时进入内存并运行,交替在CPU中运行,共享硬\软件资源;特点:宏观上并行,微观上串行
  
- 分时操作系统:把处理器的运行时间分成时间片分配给各作业;
  - 主要特征::
    - 同时性(多路性):多终端共享主机 
    - 交互性:实现人机(用户与作业)交互(**分时系统最关键的问题**)
    - 独立性:多用户独立操作
    - 及时性:用户请求能在很短时间内获得响应
  
- 实时操作系统:实现在时间限制内完成任务,无需分片排队,特点:<u>及时性 可靠性</u>
  - 硬实时系统:规定时刻发生,如飞机飞行自动控制
  - 软实时系统:允许偶尔违反时间规定,如飞机订票系统

- 并发和并行的区别:

  | 并发                                   | 并行                                 |
  | -------------------------------------- | ------------------------------------ |
  | 两个或以上事件在**同一时间间隔**内发生 | 具有可以**同时**进行运算或操作的特性 |

  例:	并发是一手筷子，一手电话，说一句话，咽一口饭。
  		 并行是咽一口饭同时说一句话，而这光靠一张嘴是办不到的，至少两张嘴。

  [^注]:并行需要相关硬件的支持,不一定是CPU

- 操作系统最基本的两个特性:并发行 共享性

- 原语

  ![1569839846080](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569839846080.png)
  
  [^注]:原语和系统调用没有必然联系
  
- 核心态(管态):进入核心态是通过**硬件**实现的；

- 用户态

  [^注]: 从用户态进入核心态不仅仅是状态的切换,其堆栈也可能切换为系统堆栈

- 特权指令与非特权指令:**用户态**下可以使用**非特权指令**，用户态下使用特权指令将产生**中断**阻止用户使用特权指令；**核心态**下可以使用所有指令；因此，用户程序放在用户态运行；**操作系统必须使用特权指令的部分放在核心态运行。**

  [^注]: 中断返回指令是特权指令,一般用于从核心态返回用户态

  - 系统调用与用户态核心态的关系m

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570697505328.png" alt="1570697505328" style="zoom:67%;" />

- 中断(外中断):来自**cpu**以外；异常(内中断\陷入)：如地址越界、算术溢出等,源自**cpu**；**系统调用的实现；**

- 大内核:将操作系统的主要功能模块作为整体来运行；代码难以维护

- 微内核:保留内核的基本功能，其他移交至**用户态**；性能较低

- 访管指令与访管中断

  ![1570006519304](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570006519304.png)


### 进程管理

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009692731.png" alt="1570009692731" style="zoom:80%;" />

- PCB(进程控制块)相关概念:
  - **程序段、相关数据段、PCB**三部分描述程序的基本情况和运行状态；这三部分相应地构成**进程映像**
  - **创建进程**实质上时创建进程映像中的PCB;撤销进程时**撤销进程**的PCB，**进程映像是静态的，进程是动态的**
  - PCB是进程存在的唯一标志
  - 将各种PCB组织起来的方式:链接和索引
- 进程的定义

![1570009447787](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009447787.png)

[^注]: 进程是进程实体的运行过程，是系统进行**资源分配和调度**的一个**独立单位**

- 就绪态和等待态的区别:就绪态等待**处理机**，等待态等待**处理机外的其他资源**

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009991483.png" alt="1570009991483" style="zoom:80%;" />

**注**：一个进程从**运行态$\to$阻塞态**是一个主动的行为，从**阻塞态$\to$就绪态**是被动行为

- 进程间的通信

  - 共享存储(通过**系统**提供的**发送消息**和**接收消息**两个原语进行)

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011348471.png" alt="1570011348471" style="zoom:80%;" />

  - 消息传递

  ![1570011392948](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011392948.png)

  **注**:消息传递分为**直接通信**和**间接通信(电子邮件)**

  - 管道通信

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011613060.png" alt="1570011613060" style="zoom:80%;" />
    **注:**管道机制必须提供以下三方面的协调能力,**互斥 同步 确定对方存在**

    ​	管道只能工作在**半双工**;工作时写进程会先把缓冲区写满,然后才让读进程读

    ​	管道大小限制,一般为4kb,本质上其是一个文件,是**消息传递**的一种特殊方式
    
    [^注]: 同一进程运行了两遍，算作两个进程

- 线程的基本概念及属性:

  - 线程不占用资源,但每个线程都有唯一标识符和**线程控制块**
  - **引入进程**是为了更好地使多道程序并发执行;**引入线程**是为了减小程序并发执行付出的时空开销,提高并发性能.
  - 线程是一个基本地**CPU执行单元**,程序执行流的**最小单元**,是被系统独立调度和分派的基本单位,**线程不拥有系统资源**(多线程中各线程可同时占用不同CPU)
  - 不同进程线程的切换才会引起进程的切换
  - 同一进程中的所有线程共享该进程所拥有的资源
  - 不同的线程可以执行相同的程序,即**同一个服务程序被不同用户调用时,OS会创建不同的线程**

- 用户级和内核级线程

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570012768484.png" alt="1570012768484" style="zoom: 67%;" />		

[^注]: 上图分别对应多对一/一对一/多对多模型

- 线程与进程的区别

| 进程                           | 线程                                    |
| ------------------------------ | --------------------------------------- |
| <u>拥有资源</u>的基本单位      | <u>独立调度</u>的基本单位               |
| 进程间通信需要同步与互斥实现   | 直接读/写进程数据段(如全局变量)进行通信 |
| 不同进程的地址空间之间相互独立 | 同一进程的不同线程共享进程的资源        |

- 线程切换与进程切换的区别:

  <u>进程切换涉及到虚拟地址空间的切换而线程切换则不会</u>。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。<u>所以线程切换是不需要内核支持,而进程切换需要内核支持，线程切换开销更小，更能提高系统的并发性。</u>

- 调度层次
  - 作业调度(高级调度):**内存**与**外存**间的调度
  - 内存调度(中级调度):提高内存利用率和系统吞吐量
  - 进程调度(低级调度):从就绪队列中选区一个进程，分配处理机

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570086852555.png" alt="1570086852555" style="zoom:67%;" />

- 系统吞吐量:单位时间**CPU**完成作业的数量

- 周转时间:作业从**提交**到**完成**所经历的时间;周转时间=作业完成时间-作业提交时间​

  带权周转时间=作业调度时间/作业实际运行时间

- 高响应比调度算法: 响应比=(等待时间+要求服务时间)/要求服务时间

- 多级反馈队列调度算法:

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570087722077.png" alt="1570087722077" style="zoom:67%;" />

  同步和互斥的区别:

  - 同步:进程间相互合作，如:消费者-生产者关系
  - 互斥:使用临界资源时,有一个进程在使用，另一个等待

- 经典进程同步问题

  - 消费者-生产者             <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571311933638.png" alt="1571311933638" style="zoom:47%;" /><img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571312037951.png" alt="1571312037951" style="zoom:47%;" />
  
    [^注]:这里必须先P(empty)后P(mutex)(重点)
  
- 读写者问题                                                                            <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571312147527.png" alt="1571312147527" style="zoom:60%;" />

- 临界区互斥的基本方法

  - 软件方法

    - 单标志法:需要进程交替进行，若一进程不打算进入临界区，则另一进程循环等待

    - 双标志法先检查(自己的临界区资源是否被访问):优点:不用交替进入  缺点:进程可能同时进入临界区

    - 双标志法后检查(自己..):先检查对方，再标志自己。会导致**饥饿(死锁)现象**

      [^注:]: 1、饥饿进程可以只有一个,而死锁进程至少两个2、饥饿可以是一个就绪进程,死锁时阻塞进程

    - peterson算法

      ![1570090848857](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570090848857.png)


[^注]: 临界

  - 进程处理机调度

    - 死等状态:进程在有限时间内根本<u>不能进入临界区</u>，而一直在尝试进入，陷入一种<u>无结果</u>的等待状态

    - 忙等状态:当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入<u>代码连续循环</u>，陷入忙等状态。连续测试一个变量直到某个值出现为止，称为忙等

    - 有限等待:对要求访问临界资源的进程，应保证有限时间内能进入自己的临界区。以免陷入“死等”状态。（受惠的是进程自己）

    - 让权等待:当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。（受惠的是其他进程）。

      | 软件实现方式 |                | 硬件实现方式 |                                 |
      | ------------ | -------------- | ------------ | ------------------------------- |
      | 单标志法     | 违背空闲让进   | 中断屏蔽法   |                                 |
      | 双标志先检查 | 违背忙则等待   | TestAndSet   |                                 |
      | 双标志后检查 | 违背有限等待   | Swap指令     |                                 |
      | Peterson算法 | 不满足让权等待 |              | 以上硬件方法都不能实现 让权等待 |

- 管程的一些重要概念

  - 管程是由一组数据以及定义在这组数据上对这组数据的操作组成的**软件模块**(**类似于抽象类**)
  - 管程的基本特性

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091943965.png" alt="1570091943965" style="zoom: 67%;" />
  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091982112.png" alt="1570091982112" style="zoom:67%;" />

  [^注]:管程是`语言成分`而不是`系统调用`

  - 管程与信号量的区别
    -  信号量支持并发;管程内部同一时刻最多只能有一个线程执行(完全互斥)
    -  信号量的P操作可能阻塞,也可能不阻塞;而管程的wait操作一定会阻塞自己  

- 死锁产生的必要条件

  - 互斥条件:

  - 不剥夺条件

  - 请求和保持

  - 循环等待

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570202852864.png" alt="1570202852864" style="zoom: 50%;" />

[^注]: 循环等待不等同于死锁,前者是后者的必要条件 资源分配图含圈系统不一定死锁(同类资源数>1)

- 死锁的处理策略

  - 预防死锁

    - 破坏互斥条件
    - 破坏不可剥夺
    - 破坏请求和保持:
      - **预先静态分配法**:进程运行前一次申请它所需的全部资源,资源未满足时不运行;<u>一旦运行，这些资源一直归他所欲</u>
    - 破坏循环等待:**顺序资源分配法**
    
  - 避免死锁
    
    - 系统安全状态:系统可按照某进程推进顺序为每个进程分配资源,使每个进程都可顺利完成
    
    [^注]: 并非所有不安全状态都是死锁状态，只是可能进入死锁;只要系统处于安全状态就不会死锁
    
    - 银行家算法
    
      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372314796.png" alt="1570372314796" style="zoom:80%;" />
      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372363483.png" alt="1570372363483" style="zoom:80%;" />
    
  - 死锁检测和解除
    
    - 资源分配图:框表示资源 圈表示进程;从进程(资源)到资源(进程)的有向边叫<u>请求边</u>(<u>分配边</u>),
    
    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372456734.png" alt="1570372456734" style="zoom:70%;" />
    
    - 死锁定理:简化资源分配图
    
    - 死锁解除
    
    - 资源剥夺法
    - 撤销进程法
    
    [^注]: 预防死锁和避免死锁都是事先预防策略
    [^注]: 死锁检测分配时不做任何动作,死锁时才采取措施
    
    



### 内存管理

- 内存管理的功能:空间的分配回收、地址转换、空间的扩充、存储保护
- 将源程序变成可执行的程序需要:
  - 1、编译:形成目标模块  2、链接:将目标模块与所需库函数链接在一起 3、装入
- 程序链接的三种方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570287607907.png" alt="1570287607907" style="zoom:80%;" />

- 装入模块的三种方式

  - 绝对装入:编译程序根据程序将驻留在内存的位置产生<u>绝对地址</u>；由于程序的逻辑地址和实际地址完全相同,故无需对程序和数据地址进行修改

  - 可重定位装入:程序中的地址从"0"开始,根据情况装入内存的适当位置

    [^注1]: 重定位:装入时对目标程序的指令和数据的修改过程;地址变换通常是在装入时一次完成的,所以又称<u>静态重定位</u>。
    [^注2]: 静态重定位的特点:a.作业装入内存时必须分配其要求的全部内存空间；b.作业一旦进入内存,整个运行期间不能在内存中移动,也不能申请内存空间

  - 动态运行时装入(动态重定位):程序在内存中若发生移动,采用动态装入.

    - 装入内存的所有地址均为**相对地址**
    - 需要**重定位寄存器**的支持
    - 可以将程序分配到<u>不连续</u>的存储区，运行期间可以动态申请内存

- 地址重定位:通过 地址转换将<u>逻辑地址</u>变成<u>物理地址</u>
- 重定位和界地址寄存器的硬件支持

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570288976486.png" alt="1570288976486" style="zoom:67%;" />

|          | 覆盖                                                         | 交换                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 主要思想 | 将用户空间分成<u>固定区</u>和<u>覆盖区</u>,活跃的部分在固定区,其余部分调用关系分段<br />将即将要访问的段调入<u>覆盖区</u>,其他在<u>外存</u>中 | 换出:把处于等待的程序从内存移到外存<br />换入:把就绪进程放入内存 |
| 特点     | ------                                                       | 交换需要备份存储<br />需要每个进程的执行时间>交换时间；影响交换时间的主要是<u>转移时间</u><br />若换出进程,则保证进程完全处于空闲状态<br />空间吃紧时启动，负荷降低就暂停 |
| 缺点     | 运行的代码量大于主存时不能运行;内存中能更新的只有覆盖区的段  | -----                                                        |

[^注]: 交换主要在不同进程间进行,覆盖(过时)则用于同一个程序或进程

- 连续分配管理方式

  - 单一连续分配:内存中只有一道程序

  - 固定分区分配:是一种<u>多道程序存储管理方式</u>，每个分区只装入一道作业；又分分区大小相等与不等

  - 动态分区分配:在**装入时**根据进程的大小动态建立分区;分区大小和数目可变;会产生**外部碎片**，可通过**紧凑技术**解决

    [^注]: 外部碎片是分区间的空闲内存区,内部碎片是分区内的空闲内存区

    - <u>动态分区</u>的分配算法

      - 首次适应:分配区内按顺序查找,找到满足要求的第一个空闲分区

      - 最佳适应:空闲分区<u>按容量递增</u>，找到第一个能满足要求的空闲分区

      - 最坏适应:空闲分区<u>按容量递减</u>，找到第一个能满足要求的空闲分区

      - 邻近适应(<u>循环首次适应</u>):和首次适应相似，区别是每次从上次查找结束的地方开始

        [^注]: 首次适应一般最简单，也是最快的；首次适应可能比最佳适应好,但它们两者一定比最大适应号

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570374233039.png" alt="1570374233039" style="zoom:80%;" />

- 非连续(离散)存储方式

  - 三种分页方式的逻辑地址结构

  1.分页

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833278353.png" alt="1569833278353" style="zoom: 80%;" />

  - 多级页表

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833343596.png" alt="1569833343596" style="zoom:80%;" />
  3.分段

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833453418.png" alt="1569833453418" style="zoom:80%;" /> 	

  - 段表的内容

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833495519.png" alt="1569833495519" style="zoom:80%;" />

  4、段页式

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833654898.png" alt="1569833654898" style="zoom:80%;" />

  5、TLB在逻辑地址中的划分

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570545896197.png" alt="1570545896197" style="zoom:67%;" />

  | 分页管理                                                     | 分段管理                                                     | 段页式管理                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
  | 每个进程建立一张页表(内存)                                   | 一个进程一张段表                                             | 一个进程一张段表，每个段一张页表             |
  | 设置一个页表寄存器(PTR)，存放<u>内存始址</u>和<u>页表长度</u>;进程未执行时页表的始址和长度都放在进程控制块(PCB)中;<br />多级页表的顶级页表只能有一个页;多级页表增加访存时间 | 段内要求连续，段间不要求;<br />设置<u>段表寄存器</u>，<br />分段管理保护方式:1、存取控制保护 2、地址越界保护 | 在一个<u>进程</u>中段表只有一个,页表可能多个 |

  [^注]: 页表长度:一共有多少页; 页表项长度:页地址占多大存储空间

  - TLB:命中率和页表命中率,cache命中率无关

- <u>传统</u>存储管理方式的特征:1、一次性:作业必须一次性全部装入内存 2、驻留性:作业装入后,一直驻留在内存

  [^注]: 分段和分页都是传统方式,满足上面两条;与<u>请求分段\分页</u>区分

- <u>虚拟</u>存储器的特征(基于离散分配的内存管理方式):1.多次性: 2.对换性 3.虚拟性:从逻辑上扩充容量

- 虚拟内存的三种的三种实现方式(都需要硬件支持)

  - 请求分页:在<u>基本分页</u>基础上增加了<u>请求调页</u>和<u>页面置换</u>

    - 相比基本分页,<u>页表项</u>增加四个字段:

      P:该页是否已在主存

       A:该页在一段时间内被访问的次数或本页有多长未被访问(供置换算法参考)

      M:标识该页在调入主存后是否被修改过

      外存地址:该页在外存上的地址

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570458997696.png" alt="1570458997696" style="zoom:80%;" />

    - 置换算法

      | 最佳置换算法(OPT)    | 先进先出(FIFO)               | 最近最久未使用(LRU)    | CLOCK算法(最近未用算法 NRU)                                  |
      | -------------------- | ---------------------------- | ---------------------- | ------------------------------------------------------------ |
      | 淘汰以后永不使用的页 | 淘汰最早进入的页(**Belady**) | 淘汰最长时间未访问的页 | 每一帧关联一个使用位,当某一页首次装入主存时,使用位=1,随后被访问,使用位也是置1<br />当替换某一页时,指针设置成<u>下一帧</u>；<br />替换页时,查找使用位=0的一帧,每遇到使用位=1,将其置0，循环操作知道找到使用位=0的一帧 |

      - 置换策略:可变分配全局置换,可变分配局部置换,固定分配局部置换(注意总结这种两两组合有四种却只有三种的概念)
  - 调页策略:预调页策略和请求调页策略
      - 改进型CLOCK算法<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570461129455.png" alt="1570461129455" style="zoom:67%;" />
              
      

- 请求分段
  
  - 请求段页式
  
    [^注]: 三种方式都需要 1.一定容量的内外存 2.页表机制 3.中断机构(内中断(详细见I/O系统)) 4.地址变换机构
  
- 交换区:即当内存空间不够用来存放程序的所有页时(只调入其中一部分到内存)，剩下的部分驻留的地方

- 工作集(驻留集):某段时间内,`一个进程`将要访问的页面;包含**最近**k次内存访问过的页面(<u>即从某个时刻的前k个页面</u>),k为工作集窗口大小

  [^注]:驻留集是某段时间内进程将要访问的页面,工作集是进程中已经调入内存的页面,一般来说驻留集包含工作集. 每个进程一个工作集
  [^注]:若题目说明工作集(驻留集)=n，在某时刻页表项的内容<=n;

### 文件管理

- 文件层次结构                                                                                                        <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571820290546.png" alt="1571820290546" style="zoom:67%;" />

  

- 文件的操作:创建\读写\重定位(寻址)\删除\截断文件:允许文件的所有属性不变,并删除文件内容
  
- 文件的属性:名称\标识符\类型\位置\大小\保护\时间日期和用户标识
  
- 文件的结构:数据项\记录\文件  [^注:在有结构文件中,文件由一组相似的记录组成]
  
- 内核中用一个<u>文件位置指针</u>指向读写位(与文件描述符fd关联);<u>同一进程</u>,指向<u>相同文件</u>的<u>不同fd</u>的文件位置指针相互独立
  
- 文件控制块(FCB):必须<u>顺序存放</u>实现<u>按名存取</u>,`FCB的有序集合为文件目录`,一个FCB就是一个文件目录项;
  - FCB包含:
    - 基本信息:文件名,文件的物理位置,文件的逻辑结构\物理结构
    - 存取控制信息:文件的存取权限
    - 使用信息:文件建立、修改时间
    - 索引节点

- 文件共享

  - 硬链接(基于索引结点):

    - 文件A是文件B的硬链接，则A的目录项中的索引节点号与B节点的**索引节点号相同**，既一个inode节点对应两个不同的文件名

    - 两个文件名指向一个同一个文件,A和B对于文件系统其实是完全相同的. **如果删除了其中一个，对另外一个没有影响.** 
    - 每增加一个文件名，索引节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，索引节点和对应数据块被回收. 
    - 只能对已存在的文件进行创建,且在同一分区；

  - 软连接

    - A是B的软链接，A的目录项中的inode节点号与B的目录项中的**inode节点号不同**，A和B指向的是两个不同的inode，继而指向两块不同的数据块，但是<u>A的**数据块**存放的只是B的路径名</u>. 
    - 如果B被删除了，A仍然存在,但指向的是一个无效的链接.
    - <u>创建软链接时，链接计数不会增加；</u>
    - <u>链接有自己的文件属性及权限等</u>
    - 可对不存在的文件或目录创建软链接
    - 只有文件的拥有着才拥有指向其索引结点的指针

- 磁盘调度算法

  - 循环扫描(cscan):<u>磁头只需要移动到最远端的一个请求即可，不需要到达磁盘端点</u>
  
    - | 顺序文件                     | 索引文件                                                     | 索引顺序文件                                                 |
      | ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | 记录按某种顺序排列形成的文件 | 每个文件对应一张索引表,<u>文件中的每个记录号,长度和指向该记录的指针计入索引表</u> | 上述两种的结合,为文件建立索引表但<u>只为每组的第一个记录设置索引表项</u> |
  
  
  
- 文件实现

  |          | 访问第n个记录           | 优点                                                         | 缺点                                      |
  | -------- | ----------------------- | ------------------------------------------------------------ | ----------------------------------------- |
  | 顺序分配 | 访盘1次                 | 当文件是<u>定长</u>时可以随机访问(类似数组)                  | 产生<u>外部碎片</u>，不利于文件的动态扩充 |
  | 链接分配 | 访盘n次                 | 解决外部碎片问题<br />分为隐式链:链表实现,头结点及指针耗费空间<br />显式链:FAT(文件分配表,<u>整个磁盘一张</u>)，静态链表实现,抽离出指针,解放空间 | 只能顺序访问                              |
  | 索引分配 | m级索引访盘<u>m+1</u>次 | 支持随机访问;优于FAT                                         | 索引表增加存储空间开销,查找策略影响大     |

  [^注1]: 索引块指向一个文件,块内每一条指向文件的<u>一个块</u>
  [^注2]: 索引表只在打开文件时才会在内存中将磁盘的索引结点拷贝一份,而FAT常驻内存,因此索引结点要比FAT更优

  [^注3]: 若涉及到移动顺序访盘1次+需移动文件块数*2(移动一个块需要读出再写入) 链接分配则n+2(寻找一个空闲块+链接)

  - 链接分配和索引分配计算文件大小的问题

    - 链表分配:<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571310165912.png" alt="1571310165912" style="zoom:67%;" />

      [^过程]: 4B=32bit的指针可以寻址$2^{32}$的空间=4G;一个块存放文件的空间=1024B-4B=1020B,最大长度=4G*1020B
    [^注]:有的题目中文件按"簇"聚合,则文件的簇号即相当于这里的指针
    
  - 顺序分配:<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571310510178.png" alt="1571310510178" style="zoom:57%;" />
    
      [^注]: $4GB=1024^2*4096B$

- 文件的存储空间管理

  - 空闲表法：<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570968737753.png" alt="1570968737753" style="zoom:67%;" />

  - 空闲盘块/盘区链表法

  - 位示图<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570968858111.png" alt="1570968858111" style="zoom:67%;" />

  - 成组链表法( https://blog.csdn.net/Ajay666/article/details/73569654 )					

     <img src="https://img-blog.csdn.net/20170622114855108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQWpheTY2Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="å¾ä¸" style="zoom:50%;" />

     问:该磁盘中目前还有多少个空闲盘块:(299)+(300)+200+99=301 [^最后一块虽然有100个块,但是结束标记占1位]

- 簇windows(块linux): <u>扇区是磁盘最小的物理存储单元</u>，OS通过将若干个扇区组成的一个更大的集合(簇)来去进行操作管理。  <u>簇是操作系统所使用的逻辑概念，而非磁盘的物理特性</u>  

- 磁盘的管理
  - 磁盘初始化
    - 低级格式化:<u>将磁盘分成扇区</u>; 
    - 为了使磁盘存储文件,操作系统还需1.将磁盘按柱面分区(C\D盘);2.对物理分区**逻辑格式化(创建文件系统)**(所以逻辑格式化不包括分区)
  - 引导块:机器启动时运行的`自举程序`;`自举装入程序`保存在rom中,完整的自举程序保存在`启动盘(系统盘)`
  - 坏块:扇区损坏,简单磁盘(IDE)手动修复,复杂磁盘(SCSI):维护坏块链表,扇区备用

### I/O管理(与计组一起看)

- 缓冲

  - 单缓冲示意图

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570535609314.png" alt="1570535609314" style="zoom:67%;" />

  - 双缓冲示意图

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570535699176.png" alt="1570535699176" style="zoom:67%;" />

- 

## DS

### 栈和队列

- 中缀表达式转后缀表达式

  - 在表达式较复杂时或求有关栈中操作符数目时用

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570689751226.png" alt="1570689751226" style="zoom:67%;" />

  - 在表达式较简单时使用

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570689450590.png" alt="1570689450590" style="zoom:70%;" />



### 树与二叉树

- 二叉排序树
  - 判断是否是二叉排序树<u>查找路径</u>的方法:
    - 1、若首结点的下一个结点的值<首结点的值,则后续所有结点都应<;
    - 2、去掉此时的首结点,返回1 递归操作
  
- 哈夫曼树:最小<u>带权路径长度</u>=$\Sigma{wi*li}$ wi为第i个结点的权值，li为该<u>叶节点到根节点的路径长度</u>(即到根节点的距离)；

  [注]:赫夫曼编码是前缀码(没有一个编码是另一个编码的前缀),判断一棵树是不是哈夫曼树,注意其WP是否为最小.

- 平衡二叉树(BBT)

  - 平衡因子:$h_l-h_r<=1$

- B树<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570956646764.png" alt="1570956646764" style="zoom:60%;" />
  
  - B树的阶:<u>所有结点</u>的孩子节点数的最大值
  
  - m阶B树的性质
    - 树中每个结点**至多**m棵子树(m-1)关键字
    - 若根节点不是终端节点,则**至少**含<u>2棵子树</u>
    - 除根结点外的所有非叶节点至少有$\lceil m/2\rceil$棵子树(即至少含有$\lceil m/2\rceil-1$个关键字)
    - 所有叶节点在同一层上且<u>不带任何信息</u>,<u>平衡因子=0</u>
    - B树的高度一般不包括最后一层
    
  - B树有关计算公式(b树的高度范围)
  
    - <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570953506377.png" alt="1570953506377" style="zoom:60%;" />
  
    - 对查找不成功的<u>叶结点(n+1)</u>(计算最大高度):<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570953960047.png" alt="1570953960047" style="zoom:57%;" />
  
      [^推导过程]: 根节点最少1个结点->第二层至少2个结点->以后的每一层在上一层的基础上$*\lceil m/2\rceil$
      [^注]: (个人做题的发现)由公式得出此时对应的B树和B+树把所有关键字存在叶子结点有点像
  
  - B树的基本操作与平衡二叉树的对比:参考:http://data.biancheng.net/view/60.html
  
    - 插入
  
      B树<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570954554169.png" alt="1570954554169" style="zoom:57%;" />
  
      BBT:像普通排序二叉树一样插入到叶节点，然后进行旋转
  
    - 删除
  
      B树
  
      - <u>如果该结点为非终端结点且不处在最后一层</u>，只需要找到结点的`直接前驱或直接后继`替换,同时删除直接前驱或直接后继
  
        (以下讨论被删结点都在最后一层)
  
      - <u>被删关键字所在结点中的关键字数目`>=⌈m/2⌉`</u>，则只需从该结点删除该关键字 Ki 以及相应的指针 
      - 被删关键字所在结点中的关键字数目==`⌈m/2⌉-1`，<u>而与该结点相邻的兄弟结点的关键字数目>`⌈m/2⌉-1`</u>:将该兄弟结点中的`最小（或者最大）`的关键字上移到双亲结点中，对于该结点,其孩子结点应满足左小右大
      - <u>被删除关键字所在的结点和其相邻的兄弟结点中的关键字数目都=⌈m/2⌉-1</u>,则将父节点中有空指针的结点向下合并
  
      BBT：只需要找到结点的`直接前驱或直接后继`替换,同时删除直接前驱或直接后继
  
  - B树与B+树的对比
  
    |                                  | B树                                      | B+树                                                         |
    | -------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
    | n个关键字的结点含有子树          | n+1                                      | n                                                            |
    | 每个非根内部结点关键字个数的范围 | $\lceil{m/2}\rceil-1<=n<=m-1$            | $\lceil{m/2}\rceil<=n<=m$                                    |
    | 叶节点                           | 不包含信息<br />各结点包含的关键字不重复 | 包含所有信息,非叶节点只起索引作用<br />非叶节点出现的关键字也会包含在叶节点中 |
    | 查找方式                         | 多路查找                                 | 多路查找 顺序查找                                            |
  
  

### <u>图</u>

- 图的一些概念

  - 简单图:1、无重复边 2、无自环 

  - 多重图:与简单图相对

  - 完全图(简单完全图):任意两顶点间都存在来回的边(无向图带两个方向)

  - 极大连通子图:该联通子图包含其所有的边(若是一个连通图,其极大连通子图就是自身)

  - 极小连通子图:保持图连通的情况下,边数最少的子图

  - 连通分量:<u>无向图</u>的极大连通子图;

  - 强连通图：从顶点u到顶点v和从顶点v到u都有路径,则称这对顶点是<u>强连通</u>,若图中任何一对顶点都是强连通的,则称此图为强连通图

  - 强连通分量:有向图的极大强连通子图

    [^注]: 强连通图\强连通分量只是针对**有向图**而言;一般的，无向图讨论连通性,有向图讨论强连通性;<u>连通分量针对连通图而言</u>

- 邻接矩阵的n次方,G(i,j)=m的意义:从i到j长度为m的路径的数量

- 简单路径与简单回路:路径上的各顶点均不重复，称这样的路径为<u>简单路径</u>；若首尾顶点相同,则为<u>简单回路</u>

- 关键路径(考前复习:两个表的填写)

  - 即图的最长路径
  - <u>只有加快那些包含于所有关键路径的活动那个才能缩短工期</u>
  
- 十字链表:<u>有向图</u>的一种链式存储结构<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026143723402.png" alt="image-20191026143723402" style="zoom: 67%;"  /><img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026143835037.png" alt="image-20191026143835037" style="zoom:67%;" />

  十字链表中,既容易找到vi的尾弧,也容易找到vi的头弧,因而容易求得顶点的出度和入度

- 临接多重表:<u>无向图</u>的一种链式存储结构

  - 边的存储结构<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026145131610.png" alt="image-20191026145131610" style="zoom:67%;" />
  - 顶点的存储结构<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026145158985.png" alt="image-20191026145158985" style="zoom:67%;" />

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026145235252.png" alt="image-20191026145235252" style="zoom:67%;" />


### 串

- kmp:感性认识,就是每次失配时,沿着失配边找到最近的一个符合位置
  - 求next数组 https://www.bilibili.com/video/av22409335?from=search&seid=2443428634678235155 <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571563510187.png" alt="1571563510187" style="zoom:40%;" />
  - 求nextval![1571570530237](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571570530237.png)

### 数组

- 广义表: 通常情况下广义表结构采用`链表`实现 

- 三元组: 将非零元素所在的行、列以及它的值构成一个三元组(i,j,n),用于优化<u>稀疏矩阵</u>的存储空间
  - 三元组矩阵的转置，经历了三个步骤：

    - 矩阵的行数 n 和列数 m 的值交换；

    - 将三元组中的i和j调换；

    - 转换之后的表同样按照行序（置换前的列序）为主序，进行排序；

      (例:三元组的转置很简单,只需交换i,j的值,						答案:错误)

### 排序

```c++
///希尔排序
for(int id=n>>1;id>=1;id<<=1){
    for(int i=1;i<=n;i++)
    if(a[i]>a[i+id]){
        a[0]=a[i+id];
        for(int j=i-id;j>0&&a[0]<a[j];j-=id){
            a[j+id]=a[j];
        }
        a[j+id]=a[0];
    }
}
```

```r
///冒泡排序
void swap(int a,int b){///O(0) swap
    a=a+b;
    b=a-b;
    a=a-b;
}

for(int i=n;i>=1;i--){
    flag=false;
    for(int j=n;j>i;j--) if(a[i]<a[i-1]) swap(a[i],a[i-1]),flag=true;
    if(!flag) return;
}

///简单选择排序
for(int i=0;i<n-1;i++){
    int min=i;
    int j;
    for(j=i+1;j<n;j++){
        if(a[min]>a[j]) min=j;
    }
    if(min!=i) swap(a[j],a[min])
}
///注:简单选择排序和冒泡排序有相似,要区分
///区别在于:选择排序每次都会把最小的和当前这趟首元素交换位置,
```

```c++
///快排
int l=1,r=n;
int Partition(int a[],int l,int r){
    int pivot=a[l];
	while(l<r){
        while(l<r&&a[r]>=pivot) r--;
        a[l]=a[r];
        while(l<r&&a[l]<=pivot) l++;
        a[r]=a[l];
    }
    a[l]=pivot;
    return l;
}

void Qsort(int a[],int l,int r){
    if(l<r){
    int pivotpos=Partition(a,l,r);
    Qsort(a,l,pivotpos);
    Qsort(a,pivotpos+1,r);
    }
}
```

```c++
///堆排序(大根堆)

void stiffDown(int a[],int k,int len){
    int a[0]=a[k];
    fot(int ch=k<<1;ch<=len;ch<<=2){
        if(ch<len&&a[ch+1]>a[ch]) ch++;
        if(a[0]>=a[ch]) break;
        a[k]=a[ch];
        k=ch;
    }
    a[k]=a[0];
}

void stiffUp(int a[],int k,int len){
    int a[0]=a[k];
	for(int pa=k>>1;pa>0;pa>>=1){
        if(a[0]>a[pa]) a[k]=a[pa]; else break;
        k=pa;
    }
    a[k]=a[0];
}

void buildMaxHeap(int a[],int len){
    for(int i=(len>>1);i>0;i--) stiffDown(a,i,len);
}

void deleteTop(int a[]){
    swap(a[1],a[len]);
    a[len--]=-1;
    stiffDown(a,1,len);
}

void insert(int a[],int k){
    a[len++]=k;
    stiffUp(a,len);
}

void heapSort(int a[],int len){
    buildMaxHeap(a,len);
    for(int i=len;i>0;i--){
        swap(a[1],a[i]);
        stiffDown(a,1,i-1)
    } 
}
```

```c++
///归并排序
void Merge(int a[],int l,int r){
    for(int i=l;i<=r;i++) B[i]=A[i];
    int mid=(l+r)>>1;
    int i;
    for(int i=0,k=l,j=mid+1;i<=mid&&j<=r;k++){
        if(B[i]<=B[j]) A[k]=B[i++];
        else A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=r) A[k++]=B[j]++;
}

void mergeSort(int a[],int l,int r){
    int mid=(l+r)>>1;
    mergeSort(a,l,mid);
    mergeSort(a,mid+1,r);
    merge(a,l,r);
}
```

- 基数排序

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000636226.png" alt="1570000636226" style="zoom: 67%;" />

各种内排序的比较

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000696976.png" alt="1570000696976" style="zoom: 67%;" />

​			**算法复杂度**与初始状态无关的有：**选择排序、堆排序、归并排序、基数排序。**

​			元素总**比较次数**与初始状态无关的有：**选择排序**、**基数排序**  **折半插入排序**。

​			元素总**移动次数**与初始状态无关的有：**归并排序**、**基数排序**。

- 外部排序

  	多路归并

![1570001947191](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570001947191.png)
**注**：理论上，增大躺数可以减少归并次数；归并趟数=$ceil(log_mr)$

​	  

​		败者树(消除m路归并,增大归并路数的影响)

![1570002634614](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570002634614.png)
			置换-选择排序

![1570003607744](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003607744.png)
![1570003716126](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003716126.png)
![1570003755469](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003755469.png)



​		最佳归并树(多路汉夫曼树):掌握不能构成严格哈夫曼树时如何新增结点

![1570004972627](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570004972627.png)

### 附录

- 涉及排列组合时常用卡特兰数:<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571384464157.png" alt="1571384464157" style="zoom:40%;" />

- 一些易错题的总结(平时多注意观察示意图)

  - 折半查找判定树                                               <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026154018979.png" alt="image-20191026154018979" style="zoom:47%;" />

    [^注]:注意这里选择中点时向下取整和向下取整应该是同一的,所以偶数结点情况下该树不是关于中轴对称的(答案:A)

  - <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191026155114886.png" alt="image-20191026155114886" style="zoom:47%;" />

    [^注]:答案D  题目中说的是第二趟排序的结果(注意一趟是指左右两半都进行一次挑选);分两种情况讨论,1、如果第-二趟选择的枢轴在中间,则第二趟后应该会产生3个枢轴,2、如果在边界则只有两个

- 各基本数据结构的定义
- 

## 网络

### 计算机网络体系结构

- 计算机网络的分类

| 按分布范围划分           | 按传输技术划分   | 按使用者划分  | 按交换技术划分             | 按拓扑结构划分      | 按传输介质 |
| ------------------------ | ---------------- | ------------- | -------------------------- | ------------------- | ---------- |
| 广域网、域域网 局域网... | 广播网、点对点网 | 公用网 专用网 | 电路交换 报文交换 分组交换 | 星形 环形 总线 网状 | 蓝牙..     |

- 总时延=发送时延(**传输时延**)+**传播时延**+处理时延+排队时延
  - 发送时延=分组长度/信道宽度
  - 传播时延:信道长度/电磁波在信道上的传播速度
  - 一般题目未提及，忽略处理时延和排队时延
- 时延带宽积=第一个比特到达终点时，发送端已经发送的比特数。直观上=传播时延*信道带宽
- 数据帧的抽象结构
  - 服务数据单元(SDU)：完成要求功能而应传送的数据
  - 协议控制信息(PCI)：控制协议操作的信息
  - 协议数据单元(PDU):**对等层之间**传送数据的的单位
  - 三者间的关联:n-PCI+n-SDU=n-PDU=(n-1)-SDU
- OSI与TCP/IP的比较

| OSI                                                          | TCP/IP                              | 协议栈                         |
| ------------------------------------------------------------ | ----------------------------------- | ------------------------------ |
| <u>应用层</u>(用户与网络的界面)                              | 应用层                              | telnet\ftp\dns\smtp\http       |
| <u>表示层</u>(数据格式的转换\编码方式的转换\数据压缩\加密解密等) | 应用层                              | --------                       |
| 会话层(管理<u>进程</u>间的会话)                              | 应用层                              | --------                       |
| 传输层                                                       | 传输层                              | TCP\UDP                        |
| 网络层                                                       | 网际层                              | IP\IPX\OSPF\ICMP\IGMP\ARP\RARP |
| 数据链路层                                                   | 网络接口层                          | SDLC\HDLC\PPP\STP              |
| 物理层                                                       | 网络接口层(网络接口$\to{}$物理接口) | EIA\CCITT                      |

**注**：OSI**网络层**支持无连接与面向连接通信，但在**传输层**只有面向连接

​		TCP/IP**网络层**只有无连接通信，**传输层**支持无连接和面向连接(认为可靠性是端到端)

​        

### 物理层

- 物理层接口的特性(规范)

  | 机械特性                                                     | 功能特性                                                     | 电气特性                                                     | 过程特性                                        |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------- |
  | 规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况 | 规定<u>传输二进制位</u>时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等 | 指明某条线上出现的某一<u>电平表示何种意义，接口部件的信号线的用途</u> | 主要定义各条物理线路的<u>工作规程和时序关系</u> |

- 码元:一个固定时长的**信号波形**,数字通信中数字信号的**计量单位**；1码元可以携带多比特的信息量

- 数据通信系统；信原、信道、信宿

  [^注]: 信道与电路不等同。信道是线路的逻辑部件

- 码元传输速率:单位时间内传送码元的个数,单位**波特**=1码元/s

  [^注]: 波特和比特是不同概念,二进制码元可以看作1bit，此时的速率叫**信息传输速率**;若一码元携带nbit信息,M baud的码元的传输速率对应的信息传输率=M*nbit/s

- 奈奎斯特定理:理想状况(无干扰)的信道中,极限码元传输率为2W baud(W:理想低通信道的带宽,单位Hz)

  [^注]: 若有V种不同的码元(离散电平数目为V),则理想低通信道下的数据传输率=$2Wlog_2V$.<u>**(bit/s)**</u>

  - 结论:
    - 在任何信道中,码元的传输速率是有上限的 
    - 信道的频带越宽可用更高的速率进行码元的有效传输
    - 给出了**码元传输速率**的限制,没有对**信息传输速率**限制(一个码元可以对应多个二进制)

- 香农定理:**带宽受限**且**有干扰**的极限数据传输速率;信道极限数据传输速率=$Wlog_2(1+S/N)$

  [^注]: W(width)为信道带宽,S(signal)为信道所传输信号的平均功率,N(noise)为信道内部的噪声功率,信噪比=$10log_{10}(S/N) 单位dB$

  - 结论:
    - 信道带宽越大或信噪比越大,传输率越大
    - 信噪比和带宽确定,传输率**上限**确定
    - 只要信息的传输率低于信道的极限传输率,就一定有办法来实现无差别传输

- 常见编码方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570192543222.png" alt="1570192543222" style="zoom:67%;" />

| 非归零码(NRZ)                         | 曼彻斯特编码   | 差分曼彻斯特      | 4B/5B |
| ------------------------------------- | -------------- | ----------------- | ----- |
| 无检错功能,无法判断一个码元的开始结束 | 以太网编码方式 | 自同步 抗干扰性好 |       |

[^注]:NRZI用电平的一次翻转来表示1,与前一个NRZI电平相同的电平表示0 NRZ高电平:1 低电平:0;
[^注]: 曼彻斯特编码中间的跳变既作时钟信号，又作数据信号 

- 调制为模拟信号

| 幅移键控(ASK)                             | 频移键控(FSK)                        | 相移键控(PSK)                                   | 正交调制                                                     |
| ----------------------------------------- | ------------------------------------ | ----------------------------------------------- | ------------------------------------------------------------ |
| 通过振幅来控制信号；比较容易实现,抗干扰差 | 通过频率来控制信号;容易实现,抗干扰强 | 通过相位来控制信号,分**绝对调相**和**相对调相** | 频率相同前提下,结合ASK和PSK；设波特率=B,m个相位,n种振幅,数据传输率=$Blog_2(m*n)$(bit/s) |

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570193187440.png" alt="1570193187440" style="zoom:67%;" />

- 采样定理
  - **抽样**是指对模拟信号进行周期性扫描,把时间上**连续的信号**变成时间上**离散的信号**，<u>当抽样的频率大于或等于模拟数据的频带带宽的**两倍**时,所得的离散信号可以无失真地代表被抽样地模拟数据</u>
  - **量化**是指把抽样取得的电平幅值按一定分级标度转化位对应的数字值，并取整
  - **编码**是把量化结果转换为与之对应地二进制编码
- 虚电路与数据报的比较

 <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570200346727.png" alt="1570200346727" style="zoom:67%;" />

- 各层设备

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571227094883.png" alt="1571227094883" style="zoom:67%;" />

|          | 网络层 | 数据链路层  | 物理层                         |
| -------- | ------ | ----------- | ------------------------------ |
| 主要设备 | 路由器 | 交换机 网桥 | 中继器(转发器):集线器(半双工): |

[^注]: 放大器放大的使<u>模拟信号</u>,中继器放大的是<u>数字信号</u>；中继器无存储转发功能,因此<u>不能连接协议不同的网段</u>
[^注]: 传输媒体不是物理层

- 各设备能否隔离广播域、冲突域

<img src="https://img-blog.csdn.net/20170107145830295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°" style="zoom: 80%;" />

### 数据链路层

- 组帧

| 字符计数法                           | 首位定界符法              | 比特填充法                                      |
| ------------------------------------ | ------------------------- | ----------------------------------------------- |
| 帧头部使用一个计数字段来表明内字符数 | 用ASCII码来定界一帧的开始 | 01111110(发送方:信息位遇到5个连续的1,自动插入0) |

- 滑动窗口流量控制

  - 发送窗口控制发送端的发送速率

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570367309301.png" alt="1570367309301" style="zoom:67%;" />

  [^注]: $W_T$表示还没有<u>收到对方确认信息</u>的情况下发送方最对可以发送多少个数据帧；接收方控制发送方发送数据的速率

  - 数据链路层和传输层滑动窗口的差别

    | 传输层滑动窗口             | 数据链路层滑动窗口                                         |
    | -------------------------- | ---------------------------------------------------------- |
    | 端到端用户之间             | 点对点相邻节点                                             |
    | (拥塞)窗口大小可以动态变化 | 窗口不可动态变化;<u>当接收窗口为1时,可保证帧的有序到达</u> |
    | 发送最小单位:字节          | 发送最小单位:数据帧                                        |

  - 停止-等待流量控制：发送(接收方)方每发送(接收)一帧，都要等接收方的应答信号才能发送下一帧；<u>如果接收方不反馈应答信号则发送方必须一直等待</u>

  - 单帧滑动窗口与停止—等待协议,(利用率低)

    - 可能出现以下两种差错
      - 到达目的站的帧已破坏； 解决:<u>源站(</u>发送方)配备计时器;计时器满则重发
      - 数据帧正确而确认帧破坏:发送方重传数据帧,<u>接收方</u>由于已收到同样的帧而丢弃该帧,同时重发确认帧
    - 超时重发和判定重复帧的需要,收发双方都设置一个<u>帧缓冲区</u>
      

    | 停止等待(SW)                  | 后退N帧(GBN)                                                 | 选择重传(SR)                                                 |
    | ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 收到上一帧的ACK后才发送下一帧 | 收到ACK前可以连续发送多帧,当发送方窗口内某个已发送的数据产生超时重发时,其后续在发送窗口内已发送的数据帧也必须重传 <br />GBN对某一数据帧的确认就表明该数据帧及以前发送的所有帧都已正确接收。 <br />稍带确认:接收方可以在当自己有数据要发送时才发送确认帧。<br />接收端仅允许<u>按序接收</u>，<u>但应重复发送已经发送过的最后一个确认帧</u> | 较GBN加大接收窗口,缓存乱序帧,等所缺序号帧收到后一起送交主机;<br />更有效的差错处理策略:一旦接收方怀疑帧出错,就发送一个NAK给发送方,要求发送方对NAK指定帧重传<br />注:SR不支持<u>累计确认</u>,逐个确认正确接收的分组 |
    | 接收窗口=发送窗口=1           | 1<=发送窗口<=$2^n-1$,接收窗口=1                              | 接收窗口($W_T$)+发送窗口($W_R$)<=$2^n$;$W_{TMAX}=W_{TMIN}=2^{n-1}$<br />注：当$W_R=1$时退化成GBN,$W_R=W_T=1$时退化成SW |
    

  [^注]: GBN

- `信道划分`介质访问控制

  - 频分复用(FDM)

  - 时分复用(TDM)

  - 波分复用(WDM):光的频分复用

  - 码分复用(CDM):CDMA码分多址是码分复用的一种形式<u>与CSMA区分</u>

    [^CDMA的相关题目]: 
     <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571229686841.png" alt="1571229686841" style="zoom:50%;" />

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571229729291.png" alt="1571229729291" style="zoom:50%;" />

- `随机访问`介质访问控制

  - CSMA不同协议的比较

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570537489197.png" alt="1570537489197" style="zoom:67%;" />

  - CSMA/CD:
    - 二进制指数退避算法:![1570538534889](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570538534889.png)
    - 争用期:2×单程传播时延，只有经过争用期还没检测到冲突才能确定这次发送不会冲突
    
  - CSMA\CA基本流程                                           <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191031154308069.png" alt="image-20191031154308069" style="zoom:50%;" />
  
    [^注]: SIFS:短帧间隔;如ACK\CTS DIFS:分布协调功能帧间隔,发送数据帧和管理帧
    [^注]:不使用用退避算法:1.检测到信道空闲 2.此帧为第一个数据帧 必须使用退避算法:1.在发送第一个帧前检测到信道忙 2.每一次重传 3.每次成功发送后再发送下一帧

| ALOHA                                                        | CSMA                                  | CSMA/CD                                                      | CSMA/CA                                                      |
| ------------------------------------------------------------ | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 不进行任何检测就发送数据;若发生冲突则让各站等待一段<u>随机时间</u>；<br />时隙ALOHA:把各站的时间上都同步起来,并把时间分为一段段等长的时隙,规定只能在每个时隙开始时发送一个帧 | 与ALOHA区别主要多了<u>载波监听</u>    | 适用于<u>总线(有线)网络和(只能)半双工网络</u>,               | 适用于无线网络                                               |
| G:网络负载(T0时刻内所有站点发送成功的和未成功而重传的帧数)<br />(普通ALOHA)吞吐量S=$Ge^{-2G}$<br />时隙ALOHA:S=$Ge^{-G}$ | 1-坚持型 <br />非坚持型<br />p-坚持型 | 先听先法,边听边发(区别CSMA),冲突停发,随机重发<br />拥塞信号:48bit<br />争用期、二进制指数退避算法<br />最小帧长=总线传播时延×数据传输速率×2(不足填充) | 1、预约信道:发送的同时向其他站点通知自己<u>传输数据的时长</u><br />2、ACK帧:站点接收后都需要向发生方发回ACK帧(<u>CSMA CSMA/CD都不用</u>)<br />3、RTS/CTS帧 (可选避免机制,用于<u>隐蔽站问题</u>) |

- 局域网
  
- 常见的局域网拓扑结构:星型结构、环形结构、总线结构、星形和总线型复合结构
  
- EEE802定义的局域网参考模型只对应于OSI的<u>数据链路层和物理层</u>,并将数据链路层拆分成<u>逻辑链路控制子层(LLC)和媒体介入控制MAC子层</u>
  
    | LLC子层                                                      | MAC子层                                                      |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 向网络层提供<u>无确认无连接,面向连接,带确认无连接，高速传送</u>四种不同的连接服务类型 | 存放接入到传输媒体有关的内容，向上屏蔽对物理层的访问的各种差异；主要功能:<u>组帧和拆卸帧</u> |
  
- 局域网介质访问控制方法:CSMA/CD、令牌总线、令牌环；前两者主要用于<u>总线局域网</u>，后者主要用于<u>环形网络</u>
  
  - 三种特殊的局域网拓扑实现
  
      | 以太网                                                   | FDDI(光纤分布数据接口,IEEE802.8)          | 令牌环                                   |
      | -------------------------------------------------------- | ----------------------------------------- | ---------------------------------------- |
    | 逻辑拓扑:总线型<br />物理拓扑:星形或拓展星形(采用集线器) | 逻辑拓扑:环形结构<br />物理拓扑：双环结构 | 逻辑拓扑:环形结构<br />物理拓扑:星形拓扑 |
  
    [^注]: 以太网采用<u>无连接</u>的工作方式,不对发送数据编号,也不要求接收方发送确认,<u>提供不可靠服务</u>
  
- 以太网的传输介质与网卡(重要,可作为题目隐含条件)
  

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570780865066.png" alt="1570780865066" style="zoom:67%;" />

[^注]: 10base-T非屏蔽双绞线以太网拓扑结构为星形,星形中心为集线器,但使用以太网在逻辑上仍然是一个总线网

- 以太网的MAC帧(会默)
  

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570781188873.png" alt="1570781188873" style="zoom:60%;" />

[^注]:以太网帧必须满足最小长度要求64B,最大1500B,当数据较少时需加以填充(**作为计算题中的默认条件**)
[^注]:MAC帧不需要帧结束符;但MAC帧需要加首部也要加尾部

- PPP协议(不可靠\**面向字节**\同步\异步\点对点, SLIP基础上改进)
  
  - 链路控制协议LCP:用于建立\配置\测试\管理<u>数据链路</u>
  
  - 网络控制协议NCP:为<u>网络层</u>协议建立和配置逻辑连接<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191106151554246.png" alt="image-20191106151554246" style="zoom:50%;" />
  
    [^注]: PPP采用的是点对点,而不是总线型,所以<u>无需采用CSMA/CD，无最短帧</u>
    [^注]:PPP只提供`差错检测`但不提供`纠错功能`,只保证`无差错接收`通过<u>硬件</u>进行CRC校验,不采用确认和序号机制
    [^注]:<u>不支持多点线路,只支持全双工</u>;PPP两端可以运行不同的网络层协议,但仍可使用同一个PPP进行通信
    [^注]:异步线路采用字节填充,同步线路采用比特填充
  
- HDLC(**面向比特**\全双工)
  
  - 非平衡配置和平衡配置
    - 非平衡:一个主站控制整个链路的工作
    - 平衡:链路两端的两个站是符合站
  
- 网桥
  
  - 设每个网段的数据率都是10Mb/s,那么三个网段合起来的最大吞吐量就是30Mb/s;如果把连接不同网段的网桥换成集线器或转发器则仍是10Mb/s
  - 网桥的特点:
    - 具备寻址和路径选择能力
    - 从源网络接收帧,以<u>目的网络</u>的介质访问控制协议向目的网络转发该帧
    - 可以在不同类型的LAN间存储转发[^一般存储转发类都可以进行协议转换]
  - 透明网桥(过程同交换机的过滤和转发)
  - 源路由网桥(选择的是最佳路由)
  
- 网卡(网络适配器):工作在数据链路层的`网络组件`
  
- 交换机(全双工)
  
  - 过滤和转发
    - 若交换机表中没有目的MAC地址字段,交换机把该帧广播到所有端口，并将该地址加入到查找表中
    - 若表中目的MAC地址对应的端口与发送端口一致，则过滤(丢弃)该帧
    - 若表中目的MAC地址对应的端口与发送端口不同,则转发到对饮端口
    
  - 两种交换模式
    - 直通式:只检查帧的目的地址,直接转发
    - 存储转发式:先将该帧接收到缓存中,检查数据是无误后转发
    
  - IEEE802.3:`基带总线`型局域网标准,<u>不可靠传输</u>
  
  - IEEE802.11:`无线局域网`的协议标准 ,采用CSMA/CA,即使在发送过程中发生碰撞,也要把整个帧发送完毕,<u>可靠传输</u>
  
    - 有固定基础设施的局域网:802.11标准规定无线局域网最小构件是基本服务集(BSS),包含一个基站和若干移动站,只有BSS内的设备可以通信,BSS外的需要AP接入
  
    - 无固定基础设施的无线局域网(Ad Hoc NetWork):一些处于<u>平等状态</u>的移动站之间相互通信组成的临时网络,无AP (类似P2P)
  
      [^注]:注意与移动IP区分;移动IP核心仍是基于固定互联网,而移动自组网是自治系统,具有自己特定的路由选择协议,可以不和因特网相连
  
      ![image-20191027171138686](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\image-20191027171138686.png)
  
      [^注]:AP地址为接收MAC帧的AP的MAC地址
  
  - 令牌环网(<u>物理上星型结构,逻辑上环形结构</u>:
  
    - TCU(耦合器):1.传递帧 2.提供接口 具有收听态和发送态
    - 媒体接入控制机制采用分布控制模式

### 网络层

- 无分类编址CIDR
  
- 构造超网(路由聚合)的两个条件:1.有相同的前缀(不一定是子网掩码) 2.路由表中下一跳的路由相同
  
  [^注]:子网号(子网地址),对应子网的所有主机号为0
  
- ICMP(Internet Control Message Protocol)

  - <u>用于目标主机或目标主机路径上的路由器向源主机报告差错和异常情况</u>，共有以下五种情况

    - 终点不可达:当路由器或主机不能交付数据报时,向源点发送不可达报文
    - 源点抑制:由于**拥塞**而丢弃数据时,发送源点抑制报文
    - 时间超过:收到生存时间(TTL)=0的数据报时,除了丢弃该报文外,还要发送时间超过报文
    - 参数问题:当收到的数据报的首部中有的字段值不正确时,丢弃该报文,并发送参数问题报文
    - 改变路由(重定向):让主机下次将数据报发送给另外的路由器(可通过更好的路由)

  - 不应该发送ICMP差错报告的几种情况

    - 对ICMP差错报文

    - 对第一个分片的数据报片的所有后续数据报片都不发送

    - 对具有<u>组播地址</u>的数据报

    - 对具有特殊地址(如0.0.0.0 127.0.0.0)的数据报

      | PING                   | Tracert          |
      | ---------------------- | ---------------- |
      | ICMP会送请求和回答报文 | ICMP时间超过报文 |
      | 应用层                 | 网络层           |


- IP(<u>无连接)</u>
  
  - MTU:最大传送单元;不同的链路协议MTU不同;
  - 片:当IP 数据报总长度>MTU时,需要将数据报分装在多个较小的IP数据报中,这些较小的数据报叫片,<u>片在目的网络层被重装</u>，它们都有<u>标识号:用来检验数据报是否来自同一原始数据报的片,</u>
  - IP数据报格式(会默)

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570706046030.png" alt="1570706046030" style="zoom:80%;" />

| IP首部的部分重要字段含义 |                                                              |
| :----------------------- | ------------------------------------------------------------ |
| 首部长度                 | 4位,以**<u>32位(4B)</u>**为单位,最大值60B(15*4B),最常用的首部长度是20B,此时不适用任何选项(可选项) |
| 总长度                   | 16位,首部长度+数据长度 <u>**单位:B**,</u>因此数据报的最大长度=$2^{16}-1$=65536 |
| 标识                     | 16位,计数器,每产生一个数据报就+1,但它并不是序号<u>(IP为无连接)</u> |
| 标志                     | 3位,MF=1,表示还有分片,MF=表示最后一个分片;DF=0,允许分片      |
| 片偏移                   | 13位.指出较长的分组在分片后,某片在原分组中的相对位置,**<u>以8B位单位</u>(**<u>即每个分片的长度一定是8B的整数倍</u>) |
| 首部检验和               | 16位,只检验分组的首部,而不检验数据部分                       |
| 生存时间TTL              | 8位;数据报在网络中<u>可通过的路由器</u>的最大值;路由器在转发分组前先把TTL-1,若TTL=0,则丢弃分组 |
| 协议                     | 8位;值为6为TCP,值为17为UDP                                   |
| 源地址字段               | 4位,标识发送方的<u>IP地址</u>                                |
| 目的地址                 | 4位标识接收方的I<u>P地址</u>                                 |

- 尽最大努力交付的含义 1.不保证无差错 2.不保证都在规定时间内交付 3.不保证按序交付 4.不保证不重复交付 5.不 故意 丢弃IP,(但是当校验和出错时可以丢弃)
- 网络层转发分组的流程

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570711610004.png" alt="1570711610004" style="zoom:67%;" />

[^注]: 得到下一跳路由器的IP地址后不是直接将该地址填入到待发送的数据报,而是将该IP地址转换成MAC地址(ARP),放到帧首部,然后根据这个MAC地址找到下一跳路由;因此,<u>IP数据报在被路由转发时,其数据链路层封装的MAC地址是不同的</u>
[^注]: 路由表一般包含:目的网络IP,子网掩码,下一跳IP,接口

- 地址解析协议(ARP)

  - 工作原理:当主机A欲向<u>本局域网</u>的主机B发送IP数据报时,先检查自己的<u>ARP缓存</u>有无主机B的IP地址,若有则将硬件地址写入MAC帧并发送;若没有就通过发送广播地址(FF-FF-FF-FF-FF-FF)

    [^注1]: ARP分组时单播
    [^注2]: 若索要求主机不再同一个局域网上,那么就ARP找到位于局域网中某个路由器的硬件地址

- 动态主机配置协议(DHCP)

  - 为主机动态分配IP地址,提供<u>即插即用</u>的联网机制;[^DHCP是应用层协议,它基于UDP]

  - 工作过程:<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571561628003.png" alt="1571561628003" style="zoom:57%;" />

    [^注]:DHCP客户机向DHCP服务器`广播发送`发现报文(本地网络上所有主机都会收到此报文,但只有DHCP服务器应答);IP分组的源IP地址:0.0.0.0 目的地址255.255.255.255
  [^注]:DHCP的<u>数据库</u>中有次此计算机的相关信息,则返回信息;若没有则分配IP地址;服务器的回答报文称为`提供报文`	
  
- 分类的IPV4地址(常考)

  - 三种类别的IP地址的使用范围

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570710633953.png" alt="1570710633953" style="zoom:80%;" />

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570710306559.png" alt="1570710306559" style="zoom:80%;" />

  [^注]: A\B\C默认子网掩码分别是255.0.0.0/255.255.0.0/255.255.255.0

  - <u>主机号全为0,标识网络自身(也可能是未有IP的主机的IP；主机号全1为本网络广播地址</u>
    32位全0标识本网络上的本主机, 32位全1表示整个TCP/IP网络的广播地址,称为<u>受限地址</u>；<u>实际使用时由于路由器对广播域隔离,等效为本网络的广播地址</u>

  - 127.0.0.0留作环路自检，不会出现在任何网络上

    [^注]: 路由器

- IPV6与IPV4的区别
  
  |                        | IPV4           | IPV6                                                     |
  | ---------------------- | -------------- | -------------------------------------------------------- |
  | 地址                   | 32bit          | 128bt                                                    |
  | 首部长度               | 4B的整数倍     | 8B的整数倍                                               |
  | 分片                   | 路由分片       | 只有在包的源节点才能分片,路由器不能分片                  |
  | 安全性                 | -----          | 身份验证和保密功能                                       |
  | IP分组头               | 12个域         | 8个域(简化分组头)                                        |
  | 目的地址的基本类型地址 | 单播 多播 广播 | 单播 多播 任播(特有):目的站是一组主机,但之交付给其中一个 |
  
  - IPV6的地址写法<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571833918138.png" alt="1571833918138" style="zoom:67%;" />
  
    [^注]:  FE80:0000:0000:0000:AAAA:0000:00C2:0002 可以简写成: FE80::AAAA:0000:00C2:0002 但是FE80::AAAA::00C2:0002是非法的。<u>0只能用::压缩一次</u> 
  
- 网络地址转换NAT:通过专用网络地址转换为公用地址,隐藏内部管理的IP地址；使整个专用网只要一个IP地址
  
  - 私有IP(可重用IP地址):

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570711139500.png" alt="1570711139500" style="zoom:80%;" />

[^注]: 普通路由器在转发IP数据报时,不改变其源IP地址和目的IP地址。<u>而NAT转发时,一定要更换其IP地址</u>；普通路由器只工作在网络层，而<u>NAT路由器转发数据报时需查看和转换传输层的端口号</u>

- 域内路由与域间路由

| 内部网关协议(IGP)                                            | 外部网关协议(EGP) |
| ------------------------------------------------------------ | ----------------- |
| RIP(广播UDP(封装)报文)\OSPF(不使用传输协议)                  | BGP(TCP封装)      |
| IGP用于一个自治系统内部,与互联网其他自治系统选用什么路由选择协议无关;EGP用于不同自治系统间 |                   |

### 传输层

- UDP
  - 分组首部开销小,TCP:20B,UDP:8B(当告知数据字段大小计算,分片时要加上对应的分组头)
  - 伪首部既不向上递交也不向下传递

- TCP协议:全双工，有连接，面向字节流，<u>累计确认</u>

  - 发送缓存:1、发送程序准备发送的数据2、TCP已发送但尚未收到确认的数据
  - 接收缓存:1、按序到达但尚未被程序读取的数据2、不按序到达的数据
  - 套接字(socket):TCP连接的端口,如192.168.1.1:80;一条TCP连接唯一地被两个套接字所确定
  - TCP报文段的首部                                <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570972017895.png" alt="1570972017895" style="zoom:67%;" />
    - 源端口\目的端口字段:各2B.[^ 注：端口是传输层与应用层的服务接口]
    - 序号字段(seq):4B.本报文段所发送的数据的第一个字节的序号
    - 确认号字段(ack):4B.是期望收到**对方的**下一个报文段的数据的第一个字节的**序号**
    - 数据偏移(首部长度):4<u>bit</u>.指出TCP报文段的`数据起始`距离`TCP报文段的起始`的距离,注意与IP数据报的片偏移区分 [^注]数据偏移以4B为计算单位,如此字段=15时,TCP首部最大长度60B(<u>掌握,常出计算题</u>)
    - 确认位(ACK):ACK=1时确认号字段有效，ACK=0时无效.<u>规定在连接建立后所有传送的报文段ACK=1</u>
    - 复用位(RST):当RST=1时,表明连接中出现严重差错,必须释放连接
    - 同步位SYN:当SYN=1,ACK=0,表明连接请求或连接接收报文,对方若同意建立连接则回复SYN=1,ACK=1
    - 窗口字段:2B 指出<u>允许发送方发送</u>的数据量,单位<u>字节</u>[^注]指的是发送此报文乙方的窗口值
    - 校验和:2B 计算校验和时在报文段前加上12B的伪首部(只需将UDP伪首部的协议字段17改成6)
    - 填充个字段:使首部长度是4B的整数倍
  - TCP连接地建立                                            <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570974673311.png" alt="1570974673311" style="zoom:60%;" />

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570973940378.png" alt="1570973940378" style="zoom:67%;" />

  [^注]: 第一步和“三次握手”一样,注意第二步,客户机收到ack=u+1的报文段,从客户机到服务器地连接就释放了,此时TCP处于半关闭状态,但服务器若发送数据,客户机仍要接收;最终A发送seq=u+1的报文后,连接没有立即断开,而是等待2MSL(最长报文段寿命)另:服务器也能选择关闭该连接;
[^注]:连接建立期间,没有数据内容的传输;SYN占用一个序号

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570974042053.png" alt="1570974042053" style="zoom:67%;" />

- TCP拥塞控制

  - 发送窗口=MIN{(接收窗口)rwnd,(拥塞窗口)cwnd} 
  - 慢开始(拥塞)
  - 快重传(丢包)     <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571730086425.png" alt="1571730086425" style="zoom:67%;" />

  [^注]: 拥塞控制与流量控制的区别:拥塞控制时全局的,流量控制只是点对点
  [^注 ]:当2*cwnd×2>sstresh(门限值)时,下一个RTT的cwnd=sstresh
  [^注]:发送方每收到一个ACK,cwnd+1,经过一个RTT后,cwnd翻倍
  [^注]:TCP协议是面向连接的,但TCP所使用的网络可以是无连接也可以是有连接
  [^注]:20B<=TCP的总长度<=MIN[(对方给出的MSS+TCP首部),65515B]  [^这里使用20B的固定长度IP首部65535-20=65515B]
  
  [^注]:数RTT个数时,数的是间隔数量

### 应用层

- HTTP：服务器与浏览器之间；面向事务；无状态(不保留客户上一次访问的状态)，通常用COOKIE(存储在用户机的<u>文本文件</u>)+数据库来追踪用户的活动。

  - HTTP采用运输层采用`TCP`协议保证数据的可靠传输,但<u>HTTP本身是无连接的</u>，即不用事先建立连接

  - HTTP的三种工作模式

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570783693745.png" alt="1570783693745" style="zoom:67%;" />

    [^注]: 第三种请求一个文档的所需时间为该文档的传输时间+2RTT(一个创建链接,一个文档接收)

- SMTP:提供可靠且有效的<u>电子邮件传输协议</u>

- POP3:简单的<u>邮件读取协议</u>

- MIME:SMTP只能传送一定长度(7bit)的ASCII码,MIME定义了传送非ASCII的规则

- 应用层协议常用端口号<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571056105076.png" alt="1571056105076" style="zoom:67%;" />

  [^注]:端口号<1023的为熟知端口号(如题目可能给你一个数据报,然后根据<u>目的端口号</u>判断是谁发送的,若目的端口号<1023则服务器是目的地)
  [^注]:DNS既工作在UDP也工作在TCP,且UDP居多

- DNS系统

  - 层次域名空间

    - 域名标号注意事项:1.标号的英文不区分大小写 2.标号只能使用'_' 3.级别最低的域名写在最左边,级别最高的写在最右边
    - 顶级域名:1.国家域名 2.通用域名,如.com 3.基础结构域名(反向域名),只有arpa,用于反向域名解析 <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571748644323.png" alt="1571748644323" style="zoom:67%;" />
- 域名服务器
  
  - 根域名服务器(13):管辖顶级服务器(所有根域名服务器都知道所有顶级域名服务器的IP地址)
    - 顶级域名服务器:管理在该顶级服务器主存的所有二级域名
    - 授权域名服务器(权限域名服务器):将其管辖的主机名转换为该主机的IP地址
    - 本地域名服务器:windows中配置的DNS服务器指的是本地域名服务器<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571749032966.png" alt="1571749032966" style="zoom:67%;" />
  - 域名解析过程[^标号为查询顺序]                                         <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571749124758.png" alt="1571749124758" style="zoom:67%;" />

- FTP ：mod:C/S  使用两个并行的TCP(数据连接:20,控制连接:21)

  - 控制连接:服务器监听在21;传输控制信息(<u>7位ASCII码</u>)

    **注:**FTP客户发送额传送请求,通过`控制连接`发送给服务器的控制进程,但<u>控制连接不传送文件,控制连接在整个会话中保持打开</u>

  - 数据连接:服务器控制进程创建"数据传送进程"和"数据连接",<u>传送完毕后关闭"数据传送连接"并结束运行</u>

   **注**:FTP的控制信息是`带外`的

### 附录

信道利用率的一些计算: https://blog.csdn.net/u011240016/article/details/53141380 

##  附录

- 单位换算:1s ＝1000ms 1ms＝1000us 1us＝1000ns 1ns＝1000ps 

