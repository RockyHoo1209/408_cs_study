# 408遗忘知识点总结

## 组原

### 第一章

- 第一台电子数字计算机:ENIAC

  | 单指令和单数据流系统SISD | 单指令多数据流系统SIMD | 多指令单数据流系统MISD | 多指令多数据流系统MIMD |
  | ------------------------ | ---------------------- | ---------------------- | ---------------------- |
  | 冯诺依曼体系结构         | 阵列处理器和向量处理器 | ________               | 多处理器和多计算机系统 |

- 冯诺依曼机的特点(SISD)

  ![1569841926106](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569841926106.png)

- 累加器 :是一种**寄存器**，用来储存计算产生的中间结果。

- 一个汉字通常占2B

- 完整的计算机系统应包括<u>硬件系统和软件系统</u>

### 数据的表示和运算

- 校验码
  - 码距:任意两个合法码之间最少变化的二进制位数;码距>=2，开始具备检错能力;码距越大，检\纠错能力越强,纠错能力>=检错能力
- 奇偶校验码

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279195718.png" alt="1570279195718" style="zoom:80%;" />

- 海明码(<u>发现双比特错,纠正单笔比特错</u>):表示法方法(n,k) n位编码,数据位k位

  - L-1=D+C (D>=C) L:最小码距 D:检错位数 C:纠错位数

    [^注]: 海明码检错d位,码距至少d+1(令上式D=0)  纠错d位,码距至少2d+1(令D=C=d)

- 海明码求解步骤(练习参见袁书习题)

  ![1570279987658](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279987658.png)

![1570279816177](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570279816177.png)

[^注]: 校验实际上是在上(4)的基础上左右亦或P1,若无措,自然结果=0

- 例2

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281565897.png" alt="1570281565897" style="zoom:70%;" />

  

- 无符号数和带符号数各种比较运算的逻辑判断式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570546936251.png" alt="1570546936251" style="zoom:67%;" />

[^注]: 无符号数相减时一般不考虑SF和OF 带符号相减时,一般不考虑CF

- 循环冗余码(CRC)

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281702819.png" alt="1570281702819" style="zoom: 80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570281737694.png" alt="1570281737694" style="zoom:80%;" />

- 强制转化(具体参考CSAPP)

| int$\to$float            | int/float$\to$double | double$\to$float  | floatdouble$\to$int |
| ------------------------ | -------------------- | ----------------- | ------------------- |
| 不会溢出,但会<u>舍入</u> | 能够保留精确的数值   | 可能溢出,可能舍入 | 向零舍入            |

- 运算(简单的不恢复余数法,记得日后补上)

  [^注]: 无符号数的减法和有符号一样,只是对于最终结果解释不同;无符号数的加法进位是在外边如10000110+11110110=(1)01111100
  
- 各编码的取值范围

  - 浮点数

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570796716639.png" alt="1570796716639" style="zoom:80%;" />

  - 定点数

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570796784899.png" alt="1570796784899" style="zoom:67%;" />

- 溢出的判别法

  - 双符号位  		<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958123808.png" alt="1570958123808" style="zoom:67%;" />
  - 单符号位![1570958177268](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958177268.png)

- 浮点数

  - 规格化<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958748114.png" alt="1570958748114" style="zoom:67%;" />![1570958939196](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570958939196.png)

    - IEEE754												<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570959039816.png" alt="1570959039816" style="zoom:67%;" /><img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570959175877.png" alt="1570959175877" style="zoom:80%;" />

      [^注]: 计算的时候记得阶码要减去偏置值或加上偏置值

      

    

- 加法器(待补充)

### 存储系统

- 存储元:存放一个二进制位的物理器件
- 存储单元:存放一个**机器字**的所有存储元;地址码相同的多个**存储元**构成存储单元
- RAM:<u>随机存储器</u> ROM:<u>只读存储器</u>  二者存取方式均为<u>随机存取</u>
- 串行访问存储器:如磁带、光盘(CD-ROM)等。包括ian<u>顺序存取存储器</u>和<u>直接存取存储器</u>:先寻找整个存储器中的某个小区域(如磁盘的磁道),再再小区域内顺序查找 
- SRAM DRAM各自得特点

![1569747278920](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569747278920.png)

[^注]: dram采用<u>地址复用技术,</u>，计算引脚时，地址线数结果除2

- 字位同时扩展:先位组成一行,然后按字变成多行.<u>此时各芯片连接地址先得方式相同,但连接数据线得方式不同</u>

- 刷新方式

  | 集中刷新                                                     | 分散刷新                                                     | 异步刷新                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
  | 固定的时间内对所有行进行刷新;停止存储器的读写操作,产生<u>死时间(死区)</u> | <u>每一行</u>的刷新分散到各个工作周期中;前半部分读写,后半部分刷新 | 结合前两种,**缩短**死时间,充分利用刷新间隔 |
  |                                                              |                                                              |                                            |

  - 刷新的相关计算      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571225259141.png" alt="1571225259141" style="zoom:67%;" />

- ROM的分类

| 掩模式只读存储器MROM                | 一次可编程只读存储器PROM                       | 可擦除可编程只读存储器EPROM                    | 闪存FLASH      | 固态存储SSD |
| ----------------------------------- | ---------------------------------------------- | ---------------------------------------------- | -------------- | ----------- |
| 生产过程直接写入,写入后无法改变内容 | 允许用户写入自己的程序,一旦写入后,内容无法改变 | 可对其内容多次改写<br />又分紫外线擦除、电擦除 | 随机访问<br /> |             |

[^注]: 一般存储体的读写速度不一致,读速度快于写速度

- 三种映射方式得地址结构

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748348509.png" alt="1569748348509" style="zoom:80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748562645.png" alt="1569748562645" style="zoom:80%;" />
<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748592130.png" alt="1569748592130" style="zoom:80%;" />

[^注]: 真题中出现过这样的组相联:例如4行二路组相联,主存地址0-1 4-5 8-9映射到0组；

- cache行的示意图(计算cache容量时用,<u>注意与地址结构区分</u>)<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571301459375.png" alt="1571301459375" style="zoom:67%;" />
  
  [^注]: 直接映射的电路的设计最为简单,全相联的最复杂
  [^注]: 看清题目问的是求`cache数据区`的大小(行大小×行数)还是`(数据)cache的大小` (1+tag+行大小)×行数 ​;还是求`地址映射表`的大小(tag+1bit)×行数)
  
  - 有关计算![1571214759080](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571214759080.png)

    假设系统有多个cache,标记位实际上就是cache的编号,因此主存容量是cache的4096倍等价于有4096个cache等价于标记位=12位;地址映射表即标记位+有效位=13bit

- 命中率

  [^注]: 若题目中说了指令cache 与数据cache分离,问算命中率则应对应算指令命中率或数据命中率(如14真题T45)

- cache的写策略

  | 写命中         |                                                              | 写不命中   |                                                     |
  | -------------- | ------------------------------------------------------------ | ---------- | --------------------------------------------------- |
  | 全写法(直泻法) | 将数据同时写入cache和主存,当某一块需要替换时只将新调入的块直接覆盖<br />写缓冲:cache和主存之间,CPU同时写数据到Cache和缓冲中,写缓冲再控制将内容写入主存 | 写分配法   | 加载主存中的块到cache中,然后更新这个cache块(局部性) |
  | 写回法         | 只修改Cache的内容,只有当此块被换出时才写回主存<br /><u>采用这种方式时每个cache行需要一位脏位</u>(重点,计算Cache容量时常考) | 非写分配法 | 只写入主存不进行调块                                |

  [^注]: 写分配法+写回法,非写分配+全写法

  

### 指令系统

- 指令的基本格式
  - 二地址指令<u>:目的操作数</u>用于保存本次<u>运算结果</u>(大题中出现二地址指令,默认知道此条)
- 常见的<u>数据寻址</u>方式

| <font size=2>隐含寻址</font>                             | <font size=2>立即数..</font>                      | <font size=2>直接..</font> | <font size=2>间接..</font> |   <font size=2>寄存器..</font>   | <font size=2>寄存器间接.. </font> | <font size=2>相对..</font> | <font size=2>基址</font>                                | <font size=2>变址</font>                                | <font size=2>堆栈</font> |
| ----------------------------------------------------------- | ------------------------------------------------------ | -------------------------- | ----------------------------- | :------------: | -------------- | :--------------: | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------- |
| <font size=2>指令中隐含操作数地址</font>                    |OP=A                                                   | EA=A                       | <font size=2>EA=(A)</font>   | EA=$R_A$    | <font size=2>EA=($R_A$)</font> | EA=PC+(A)       | EA=(BR)+A                                                 | EA=(IX)+A                                                    | <font size=2>硬堆栈 (寄存器堆栈)\软堆栈</font> |
| <font size=2>单地址指令只给出第一操作数地址,<u>ACC</u>作为第二操作数地址</font> | <font size=2>数据采用**补码**存放;执行不访问主存,<br />执行时间最短</font> | <font size=2>指令地址位数决定了寻址范围</font> | <font size=2>可扩大寻址范围,但需要多次访存</font> | <font size=2>执行阶段不访存</font> | <font size=2>同间接寻址可扩大范围,但查找速度比间接快 </font> | <font size=2>广泛用于转移指令</font> | <font size=2>基址寄存器可以是通用寄存器也可以是专用寄存器;<br />用户可以决定哪个寄存器,但<u>内容由操作系统决定</u>(<u>面向操作系统</u>)</font> | <font size=2>变址寄存器<u>面向用户</u><br />可用变址寄存器(<u>专用</u>)也可用通用寄存器<br />常用于<u>数组处理</u></font> | <font size=2>自动完成对SP的增量减量操作</font> |

[^注]: 数据通路:各个功能部件通过数据总线连接形成的<u>数据传输路径</u>;数据总线是承载数据的<u>媒介</u>
[^注]: 数据寻址比指令寻址复杂 指令寻址一般在内存,数据寻址还可能在寄存器,I/O端口

- 从处理器设计的角度,定长指令要比变长指令好

- 变长指令的有关计算
  - 首先从地址数目最多的出发,用指令字长减去地址位数得到n,则该类型指令还剩$2^n-k_2$
  - 然后左移一个地址码的位数(相当于地址码数-1),此时得到的是一地址指令的总数目，重复第一步
    - 例题<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571057177129.png" alt="1571057177129" style="zoom:80%;" />

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571057305882.png" alt="1571057305882" style="zoom:80%;" />

- 转移指令和调用(转子)指令的区别

  转移指令分条件转移(分支指令)和无条件转移,<u>转移后不再返回来执行</u>

  调用(转子)指令:除了转移外,转移后还要保存返回地址
  
- 问指令是否有数据相关的题:画出指令流水过程图,

  - 注意若指令间存在数据相关则只有在上一条相关指令的WB(写回)后才可以执行ID(指令译码)

  - 下一条ID和上一条的IF对齐

    [^注]: 这种题目都先观察,如果复杂(题目没有要求)的就在草稿纸上作草图

### 中央处理器

- 微指令编码方式

  - 水平型(并行性好，但指令长,不利于边写微程序)

    - 直接编码(无需译码):<u>每一位</u>代表一个微命令

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570690837701.png" alt="1570690837701" style="zoom:67%;" />

    - 字段直接编码(用二进制编码操作控制端)

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570691112841.png" alt="1570691112841" style="zoom:67%;" />

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570691026083.png" alt="1570691026083" style="zoom:80%;" />

    - 字段间接编码:一个字段中的某些微命令需要另一个字段中的某些微命令来解释

  - 垂直型(与水平型相对,类似机器指令操作码)<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570692044203.png" alt="1570692044203" style="zoom: 80%;" />
    

- 微程序、微命令、微指令、微操作的关系

| 微命令           | 微操作                                  | 微指令                                     | 微程序                  |
| ---------------- | --------------------------------------- | ------------------------------------------ | ----------------------- |
| 若干微命令的集合 | 执行部件接受<u>微命令</u>后所执行的操作 | 控制部件通过控制线向执行部件发出各种控制命 | <u>微指令</u>的有序集合 |

[^注]: 存放微指令的控制存储器单元成为<u>微地址</u> 

- 微周期:从控存中<u>读取</u>一条微指令并<u>执行</u>相应微操作的时间(与指令周期类似)

- 控存容量的计算:$2^n*b$    n为下地址字段的位数,b为微指令的位数(存疑)

- 机器周期和时钟周期的区别

  | 时钟周期                                                     | 机器周期(CPU周期)                                            |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | CPU的晶振的工作频率的倒数，是**计算机中最基本的、最小的时间单位** | CPU完成一项基本任务的时间,如指令周期被分成多个机器周期(IF ID...) |

  

### 总线

- 按功能划分总线

| 片内总线        | 系统总线                                                     | 通信总线                                                 |
| --------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| CPU芯片内的总系 | 按传输内容分可分为:<br />数据总线(双向):传输各功能部件的<u>信息(如除了地址和信号外的所有信息）</u><br />地址总线(单向):指出主存单元或i/o地址<br />控制总线:传输<u>控制信号、命令、总线(中断)请求\允许</u> | 计算机系统与其他系统之间信息传送的总线,如<u>握手信号</u> |

- 总线的分类

| 系统总线 | 局部总线               | 设备总线 | 其他                               |
| -------- | ---------------------- | -------- | ---------------------------------- |
| ISA      | VESA\PCI(即插即用)\AGP | USB      | EISA\PCI-E\RS-232C\PCMCIA\IDE\SATA |

[^注]: USB和RS232为串行总线,每次只能传输1位数据

- 突发传送:只需传送开始时给出数据块的首地址,然后连续传送多个数据，能实现一个时钟传送多个数据(可理解为多个单元数据当作一个单元数据传送)

  [^注]: 计算时$T_{总线}=T_{传递址}+T_{连续数据}$，一般传地址也是一个总线周期

  

### I/O系统

- IO软件系统的层次(由上到下):用户级IO软件->设备无关的操作系统软件->设备驱动程序->中断处理程序->硬件

- IO端口及其编址

  |                        |                                                              |
  | ---------------------- | ------------------------------------------------------------ |
  | 统一编址(存储映射方式) | 把IO端口当作存储器单元进行地址分配,CPU不需要设置转么的IO指令 |
  | 独立编址(I/0映射方式)  | IO端口地址与存储器地址无关,需要设置专门的访问端口            |

- IO端口类型:数据端口、控制端口、状态端口(与三大总线区分,所以不传送地址)

- 中断响应优先级和中断处理优先级的区别:前者由硬件排队线路或中断查询的查询顺序决定的,不可动态改变;后者可通过设置中断屏蔽字来改变

- 总线仲裁

  - 集中总线仲裁

    BR:总线请求 BS总线忙 BG:总线允许 n:设备个数

    |          | 链式查询                         | 计数器定时查询                                               | 独立请求              |
    | -------- | -------------------------------- | ------------------------------------------------------------ | --------------------- |
    | 控制线数 | 3(BS:1 BR:1 BG:1)                | $\lceil log_2n\rceil$+2(BR:1 BS:1 BG: $\lceil log_2n\rceil$) | 2n+1(BR:n BG:n BS:1)  |
    | 特点     | 优先级固定,扩充容易              | 优先级灵活                                                   | 响应速度块,优先级灵活 |
    | 缺点     | 效率低;优先级不灵活,电路故障敏感 | 控制线多,控制复杂                                            | 控制线多,控制复杂     |

    [^注]: 链式查询总线响应信号串行传输,依次查询，像链条一样，所以每个各一根;
    [^]:     计数器查询,将每个计数器按二进制编号,n个设备,只需$log_2n$位,对应总线允许;独立请求每个设备独立占用一根BG BR;BS都是公用

    ​			   

  - 分布式仲裁:不需要中央仲裁器,每个潜在的主模块都有自己的仲裁号和仲裁器

- (CPU)内中断(CPU) 外中断

| 内中断(软中断)                                               | 外中断(硬中断)                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可以在指令执行期间产生和处理中断信号,指CPU内产生的中断<br /><u>同步</u><u>,分为陷阱\故障\终止</u><br />一般由指令引起,如:缺页中断\算术溢出\除数为...<br />可能终止当前执行的程序也可能返回 | 在每条指令的结束时响应,CPU外产生的中断<br /><u>异步</u><br />一般由外部引起,,不由指令引起如:IO中断 |

[^注]: 中断判优中一般硬件故障>软中断>非屏蔽>屏蔽;DMA>IO传送的中断请求
[^注]: 中断发生时,操纵系统保存所有通用寄存器的内容(包括PSW),可能设置TLB和MMU和页表,CPU保存PC



- 中断的处理流程

| 单重中断                                     | 多重中断(中断嵌套)                           |
| -------------------------------------------- | -------------------------------------------- |
| 关中断**(中断隐指令(硬件))**(向下到保护现场) | 关中断(**中断隐指令((硬件))**向下到保护现场) |
| 保存断点(pc)                                 | 保存断点(pc)                                 |
| 送中断向量                                   | 送中断向量                                   |
| 保护现场**(中断服务程序)**(向下都是)         | 保护现场和屏蔽字**(中断服务程序)**(向下都是) |
| ---------                                    | 开中断                                       |
| 执行中断服务程序                             | 执行中断服务程序                             |
| ----------                                   | 关中断                                       |
| 恢复现场                                     | 恢复现场和屏蔽字                             |
| 开中断                                       | 开中断                                       |
| 中断返回                                     | 中断返回                                     |

[^注1]: 中断隐指令不是一条真正的指令,没有操作码
[^注2]: 中断向量:中服务程序的入口地址;中断向量地址:中断向量的地址(程序入口地址的地址)
[^注3]: 硬件产生中断类型号,中断类型号指出中断向量地址

- DMA(Direct Memory Access)的有关概念

  - CPU在一次<u>总线操作结束</u>时,一旦发现DMA请求,就立即释放总线

  - 周期挪用:当DMA与CPU冲突时,**CPU挪出一个主存存储周期**给DMA访问内存

  - DMA传送流程图

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570694175405.png" alt="1570694175405" style="zoom:67%;" />

- 通道控制方式:通道指专门负责IO的<u>处理机</u>

  - 与一般处理机的区别:1.通道指令类型单一 2.没有自己的内存 ,通道与CPU共享内存
  - 与DMA的区别:通道拥有更高的自主权,数据块大小、传输的内存位置，都可以自己决定

- SPOOLING

- 廉价磁盘阵列(RAID)

| RAID0 | 无冗余码和无检验码       |
| ----- | ------------------------ |
| RAID1 | 镜像磁盘阵列             |
| RAID2 | 采用海明码               |
| RAID3 | 采用位交叉奇偶校验       |
| RAID4 | 采用块交叉奇偶校验       |
| RAID5 | 采用无独立校验的奇偶校验 |

- (了解)条带化strip:是把连续的数据分割成相同大小的数据块，把每段数据分别写入到阵列中的不同磁盘上的方法。简单的说，条带是一种将多个磁盘驱动器合并为一个卷的方法。 许多情况下，这是通过硬件控制器来完成的
- 磁盘存储器
  - 磁盘读写的最小单位:扇区(块)，存储单位:B
  - 磁盘所有磁道记录的信息量相等
  - <u>平均存取时间(重点)</u>:寻道时间+旋转时间+<u>传输时间(旋转一圈半周期的时间</u>)

### 附录:

- 计算机性能的一些指标

| MIPS(Million Instructions Per Second) | CPI                                                          | MFLOPS                       |
| ------------------------------------- | ------------------------------------------------------------ | ---------------------------- |
| 每秒执行对少百万条指令                | 平均每条指令的时钟周期数<br />IPC:CPI的倒数,每个时钟周期执行多少条指令 | 每秒执行多少百万条浮点数运算 |

- 

## OS

### 概述

- 并发和并行的区别:

  | 并发                                   | 并行                                 |
  | -------------------------------------- | ------------------------------------ |
  | 两个或以上事件在**同一时间间隔**内发生 | 具有可以**同时**进行运算或操作的特性 |

  例:	并发是一手筷子，一手电话，说一句话，咽一口饭。
  		 并行是咽一口饭同时说一句话，而这光靠一张嘴是办不到的，至少两张嘴。

- 操作系统最基本的两个特性:并发行 共享性

- 原语

  ![1569839846080](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569839846080.png)
  
- 核心态(管态):进入核心态是通过**硬件**实现的；

- 用户态

  [^注]: 从用户态进入核心态不仅仅是状态的切换,其堆栈也可能切换为系统堆栈

- 特权指令与非特权指令:**用户态**下可以使用**非特权指令**，用户态下使用特权指令将产生**中断**阻止用户使用特权指令；**核心态**下可以使用所有指令；因此，用户程序放在用户态运行；**操作系统必须使用特权指令的部分放在核心态运行。**

  [^注]: 中断返回指令是特权指令,一般用于从核心态返回用户态

  - 系统调用与用户态核心态的关系m

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570697505328.png" alt="1570697505328" style="zoom:67%;" />

- 中断(外中断):来自**cpu**以外；异常(内中断\陷入)：如地址越界、算术溢出等,源自**cpu**；**系统调用的实现；**

- 大内核:将操作系统的主要功能模块作为整体来运行；代码难以维护

- 微内核:保留内核的基本功能，其他移交至**用户态**；性能较低

- 访管指令与访管中断

  ![1570006519304](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570006519304.png)


### 进程管理

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009692731.png" alt="1570009692731" style="zoom:80%;" />

- PCB(进程控制块)相关概念:
  - **程序段、相关数据段、PCB**三部分描述程序的基本情况和运行状态；这三部分相应地构成**进程映像**
  - **创建进程**实质上时创建进程映像中的PCB;撤销进程时**撤销进程**的PCB，**进程映像是静态的，进程是动态的**
  - PCB是进程存在的唯一标志
  - 将各种PCB组织起来的方式:链接和索引
- 进程的定义

![1570009447787](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009447787.png)

[^注]: 进程是进程实体的运行过程，是系统进行**资源分配和调度**的一个**独立单位**

- 就绪态和等待态的区别:就绪态等待**处理机**，等待态等待**处理机外的其他资源**

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570009991483.png" alt="1570009991483" style="zoom:80%;" />

**注**：一个进程从**运行态$\to$阻塞态**是一个主动的行为，从**阻塞态$\to$就绪态**是被动行为

- 进程间的通信

  - 共享存储(通过**系统**提供的**发送消息**和**接收消息**两个原语进行)

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011348471.png" alt="1570011348471" style="zoom:80%;" />

  - 消息传递

  ![1570011392948](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011392948.png)

  **注**:消息传递分为**直接通信**和**间接通信(电子邮件)**

  - 管道通信

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570011613060.png" alt="1570011613060" style="zoom:80%;" />
    **注:**管道机制必须提供以下三方面的协调能力,**互斥 同步 确定对方存在**

    ​	管道只能工作在**半双工**;工作时写进程会先把缓冲区写满,然后才让读进程读

    ​	管道大小限制,一般为4kb,本质上其是一个文件,是**消息传递**的一种特殊方式
    
    [^注]: 同一进程运行了两遍，算作两个进程

- 线程的基本概念及属性:

  - 线程不占用资源,但每个线程都有唯一标识符和**线程控制块**
  - **引入进程**是为了更好地使多道程序并发执行;**引入线程**是为了减小程序并发执行付出的时空开销,提高并发性能.
  - 线程是一个基本地**CPU执行单元**,程序执行流的**最小单元**,是被系统独立调度和分派的基本单位,**线程不拥有系统资源**(多线程中线程各线程可同时占用不同CPU)
  - 不同进程线程的切换才会引起进程的切换
  - 同一进程中的所有线程共享该进程所拥有的资源
  - 不同的线程可以执行相同的程序,即**同一个服务程序被不同用户调用时,OS会创建不同的线程**

- 用户级和内核级线程

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570012768484.png" alt="1570012768484" style="zoom: 67%;" />		

[^注]: 上图分别对应多对一/一对一/多对多模型

- 线程与进程的区别

| 进程                           | 线程                                    |
| ------------------------------ | --------------------------------------- |
| <u>拥有资源</u>的基本单位      | <u>独立调度</u>的基本单位               |
| 进程间通信需要同步与互斥实现   | 直接读/写进程数据段(如全局变量)进行通信 |
| 不同进程的地址空间之间相互独立 | 同一进程的不同线程共享进程的资源        |

- 线程切换与进程切换的区别:

  <u>进程切换涉及到虚拟地址空间的切换而线程切换则不会</u>。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。<u>所以线程切换是不需要内核支持,而进程切换需要内核支持，线程切换开销更小，更能提高系统的并发性。</u>

- 调度层次
  - 作业调度(高级调度):**内存**与**外存**间的调度
  - 内存调度(中级调度):提高内存利用率和系统吞吐量
  - 进程调度(低级调度):从就绪队列中选区一个进程，分配处理机

![1570086852555](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570086852555.png)

- 系统吞吐量:单位时间**CPU**完成作业的数量

- 周转时间:作业从**提交**到**完成**所经历的时间;周转时间=作业完成时间-作业提交时间​

  带权周转时间=作业调度时间/作业实际运行时间

- 高响应比调度算法: 响应比=(等待时间+要求服务时间)/要求服务时间

- 多级反馈队列调度算法:

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570087722077.png" alt="1570087722077" style="zoom:67%;" />

  同步和互斥的区别:

  - 同步:进程间相互合作，如:消费者-生产者关系
  - 互斥:使用临界资源时,有一个进程在使用，另一个等待

- 经典进程同步问题

  - 消费者-生产者             <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571311933638.png" alt="1571311933638" style="zoom:47%;" /><img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571312037951.png" alt="1571312037951" style="zoom:47%;" />
- 读写者问题                                                                            <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571312147527.png" alt="1571312147527" style="zoom:60%;" />

- 临界区互斥的基本方法

  - 软件方法

    - 单标志法:需要进程交替进行，若一进程不打算进入临界区，则另一进程循环等待

    - 双标志法先检查(自己的临界区资源是否被访问):优点:不用交替进入  缺点:进程可能同时进入临界区

    - 双标志法后检查(自己..):先检查对方，再标志自己。会导致**饥饿(死锁)现象**

      [^注:]: 1、饥饿进程可以只有一个,而死锁进程至少两个2、饥饿可以是一个就绪进程,死锁时阻塞进程

    - peterson算法

      ![1570090848857](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570090848857.png)

  - 硬件方法

    - TestAndSet Swap指令由逻辑电路直接实现，**不会被中断**

  [^注]: 临界

- 管程的一些重要概念

  - 管程是由一组数据以及定义再这组数据上对这组数据的操作组成的**软件模块**(类似于抽象类)
  - 管程的基本特性

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091943965.png" alt="1570091943965" style="zoom: 67%;" />
  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570091982112.png" alt="1570091982112" style="zoom:67%;" />

- 死锁产生的必要条件

  - 互斥条件:

  - 不剥夺条件

  - 请求和保持

  - 循环等待

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570202852864.png" alt="1570202852864" style="zoom: 50%;" />

[^注]: 循环等待不等同于死锁,前者是后者的必要条件 资源分配图含圈系统不一定死锁(同类资源数>1)

- 死锁的处理策略

  - 预防死锁

    - 破坏互斥条件
    - 破坏不可剥夺
    - 破坏请求和保持:
      - **预先静态分配法**:进程运行前一次申请它所需的全部资源,资源未满足时不运行;<u>一旦运行，这些资源一直归他所欲</u>
  - 破坏循环等待:**顺序资源分配法**
  
- 避免死锁
  
  - 系统安全状态:系统可按照某进程推进顺序为每个进程分配资源,使每个进程都可顺利完成
  
    [^注]: 并非所有不安全状态都是死锁状态，只是可能进入死锁;只要系统处于安全状态就不会死锁
  
  - 银行家算法
  
    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372314796.png" alt="1570372314796" style="zoom:80%;" />
  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372363483.png" alt="1570372363483" style="zoom:80%;" />
  
- 死锁检测和解除
  
  - 资源分配图:框表示资源 圈表示进程;从进程(资源)到资源(进程)的有向边叫<u>请求边</u>(<u>分配边</u>),
  
    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570372456734.png" alt="1570372456734" style="zoom:70%;" />
  
  - 死锁定理:简化资源分配图
  
  - 死锁解除
  
      - 资源剥夺法
    - 撤销进程法
  
    [^注]: 预防死锁和避免死锁都是事先预防策略
    [^注]: 死锁检测分配时不做任何动作,死锁时才采取措施
    
    



### 内存管理

- 内存管理的功能:空间的分配回收、地址转换、空间的扩充、存储保护
- 将源程序变成可执行的程序需要:
  - 1、编译:形成目标模块  2、链接:将目标模块与所需库函数链接在一起 3、装入
- 程序链接的三种方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570287607907.png" alt="1570287607907" style="zoom:80%;" />

- 装入模块的三种方式

  - 绝对装入:编译程序根据程序将驻留在内存的位置产生<u>绝对地址</u>；由于程序的逻辑地址和实际地址完全相同,故无需对程序和数据地址进行修改

  - 可重定位装入:程序中的地址从"0"开始,根据情况装入内存的适当位置

    [^注1]: 重定位:装入时对目标程序的指令和数据的修改过程;地址变换通常是在装入时一次完成的,所以又称<u>静态重定位</u>。
    [^注2]: 静态重定位的特点:a.作业装入内存时必须分配其要求的全部内存空间；b.作业一旦进入内存,整个运行期间不能在内存中移动,也不能申请内存空间

  - 动态运行时装入(动态重定位):程序在内存中若发生移动,采用动态装入.

    - 装入内存的所有地址均为**相对地址**
    - 需要**重定位寄存器**的支持
    - 可以将程序分配到<u>不连续</u>的存储区，运行期间可以动态申请内存

- 址重定位:通过 地址转换将<u>逻辑地址</u>变成<u>物理地址</u>
- 重定位和界地址寄存器的硬件支持

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570288976486.png" alt="1570288976486" style="zoom:67%;" />

|          | 覆盖                                                         | 交换                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 主要思想 | 将用户空间分成<u>固定区</u>和<u>覆盖区</u>,活跃的部分在固定区,其余部分调用关系分段<br />将即将要访问的段调入<u>覆盖区</u>,其他在<u>外存</u>中 | 换出:把处于等待的程序从内存移到外存<br />换入:把就绪进程放入内存 |
| 特点     | ------                                                       | 交换需要备份存储<br />需要每个进程的执行时间>交换时间；影响交换时间的主要是<u>转移时间</u><br />若换出进程,则保证济南城完全处于空闲状态<br />空间吃紧时启动，负荷降低就暂停 |
| 缺点     | 运行的代码量大于主存时不能运行;内存中能更新的只有覆盖区的段  | -----                                                        |

[^注]: 交换主要在不同进程间进行,覆盖(过时)则用于同一个程序或进程

- 连续分配管理方式

  - 单一连续分配:内存中只有一道程序

  - 固定分区分配:是一种<u>多道程序存储管理方式</u>，每个分区只装入一道作业；又分分区大小相等与不等

  - 动态分区分配:在**装入时**根据进程的大小动态建立分区;分区大小和数目可变;会产生**外部碎片**，可通过**紧凑技术**解决

    [^注]: 外部碎片是分区间的空闲内存区,内部碎片是分区内的空闲内存区

    - <u>动态分区</u>的分配算法

      - 首次适应:分配区内按顺序查找,找到满足要求的第一个空闲分区

      - 最佳适应:空闲分区<u>按容量递增</u>，找到第一个能满足要求的空闲分区

      - 最坏适应:空闲分区<u>按容量递减</u>，找到第一个能满足要求的空闲分区

      - 邻近适应(<u>循环首次适应</u>):和首次适应相似，区别是每次从上次查找结束的地方开始

        [^注]: 首次适应一般最简单，也是最快的；首次适应可能比最佳适应好,但它们两者一定比最大适应号

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570374233039.png" alt="1570374233039" style="zoom:80%;" />

- 非连续(离散)存储方式

  - 三种分页方式的逻辑地址结构

  1.分页

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833278353.png" alt="1569833278353" style="zoom: 80%;" />

  - 多级页表

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833343596.png" alt="1569833343596" style="zoom:80%;" />
  3.分段

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833453418.png" alt="1569833453418" style="zoom:80%;" /> 	

  - 段表的内容

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833495519.png" alt="1569833495519" style="zoom:80%;" />

  4、段页式

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833654898.png" alt="1569833654898" style="zoom:80%;" />

  5、TLB在逻辑地址中的划分

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570545896197.png" alt="1570545896197" style="zoom:67%;" />

  | 分页管理                                                     | 分段管理                                                     | 段页式管理                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
  | 每个进程建立一张页表(内存)                                   | 一个进程一张段表                                             | 一个进程一张段表，每个段一张页表             |
  | 设置一个页表寄存器(PTR)，存放<u>内存始址</u>和<u>页表长度</u>;进程未执行时页表的始址和长度都放在进程控制块(PCB)中;<br />多级页表的顶级页表只能有一个页;多级页表增加访存时间 | 段内要求连续，段间不要求;<br />设置<u>段表寄存器</u>，<br />分段管理保护方式:1、存取控制保护 2、地址越界保护 | 在一个<u>进程</u>中段表只有一个,页表可能多个 |

  [^注]: 页表长度:一共有多少页; 页表项长度:页地址占多大存储空间

  - TLB:命中率和页表命中率,cache命中率无关

- <u>传统</u>存储管理方式的特征:1、一次性:作业必须一次性全部装入内存 2、驻留性:作业装入后,一直驻留在内存

  [^注]: 分段和分页都是传统方式,都时

- <u>虚拟</u>存储器的特征(基于离散分配的内存管理方式):1.多次性: 2.对换性 3.虚拟性:从逻辑上扩充容量

- 虚拟内存的三种的三种实现方式(都需要硬件支持)

  - 请求分页:在<u>基本分页</u>基础上增加了<u>请求调页</u>和<u>页面置换</u>

    - 相比基本分页,<u>页表项</u>增加四个字段:

      P:该页是否已在主存

       A:该页在一段时间内被访问的次数或本页有多长未被访问(供置换算法参考)

      M:标识该页在调入主存后是否被修改过

      外存地址:该页在外存上的地址

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570458997696.png" alt="1570458997696" style="zoom:80%;" />

    - 置换算法

      | 最佳置换算法(OPT)    | 先进先出(FIFO)               | 最近最久未使用(LRU)    | CLOCK算法(最近未用算法 NRU)                                  |
      | -------------------- | ---------------------------- | ---------------------- | ------------------------------------------------------------ |
      | 淘汰以后永不使用的页 | 淘汰最早进入的页(**Belady**) | 淘汰最长时间未访问的页 | 每一帧关联一个使用位,当某一页首次装入主存时,使用位=1,随后被访问,使用位也是置1<br />当替换某一页时,指针设置成<u>下一帧</u>；<br />替换页时,查找使用位=0的一帧,没遇到使用位=1,将其置0，循环操作知道找到使用位=0的一帧 |

      - 改进型CLOCK算法

      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570461129455.png" alt="1570461129455" style="zoom:67%;" />

  - 请求分段

  - 请求段页式

    [^注]: 三种方式都需要 1.一定容量的内外村 2.页表机制 3.中断机构(内中断(详细见I/O系统)) 4.地址变换机构
  
- 交换区:即当内存空间不够用来存放程序的所有页时(只调入其中一部分到内存)，剩下的部分驻留的地方

### 文件管理

- 文件控制块(FCB):必须<u>顺序存放</u>实现<u>按名存取</u>,`FCB的有序集合为文件目录`,一个FCB就是一个文件目录项;
  - FCB包含:
    - 基本信息:文件名,文件的物理位置,文件的逻辑结构\物理结构
    - 存取控制信息:文件的存取权限
    - 使用信息:文件建立、修改时间
    - 索引节点

- 文件共享

  - 硬链接(基于索引结点):

    - 文件A是文件B的硬链接，则A的目录项中的索引节点号与B节点的**索引节点号相同**，既一个inode节点对应两个不同的文件名

    - 两个文件名指向一个同一个文件,A和B对于文件系统其实是完全相同的. **如果删除了其中一个，对另外一个没有影响.** 
    - 每增加一个文件名，索引节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，索引节点和对应数据块被回收. 
    - 只能对已存在的文件进行创建；

  - 软连接

    - A是B的软链接，A的目录项中的inode节点号与B的目录项中的**inode节点号不同**，A和B指向的是两个不同的inode，继而指向两块不同的数据块，但是<u>A的**数据块**存放的只是B的路径名</u>. 
    - 如果B被删除了，A仍然存在,但指向的是一个无效的链接.
    - <u>创建软链接时，链接计数不会增加；</u>
    - <u>链接有自己的文件属性及权限等</u>
    - 可对不存在的文件或目录创建软链接
    - 只有文件的拥有着才拥有指向其索引结点的指针

- 磁盘调度算法

  - 循环扫描(cscan):<u>磁头只需要移动到最远端的一个请求即可，不需要到达磁盘端点</u>
  
- 文件实现

  |          | 访问第n个记录    | 优点                                                         | 缺点                                      |
  | -------- | ---------------- | ------------------------------------------------------------ | ----------------------------------------- |
  | 顺序分配 | 访盘1次          | 当文件是<u>定长</u>时可以随机访问(类似数组)                  | 产生<u>外部碎片</u>，不利于文件的动态扩充 |
  | 链接分配 | 访盘n次          | 解决外部碎片问题<br />分为隐式链:链表实现,头结点及指针耗费空间<br />显式链:FAT(文件分配表,<u>整个磁盘一张</u>)，静态链表实现,抽离出指针,解放空间 | 只能顺序访问                              |
  | 索引分配 | m级索引访盘m+1次 | 支持随机访问;优于FAT                                         | 索引表增加存储空间开销,查找策略影响大     |

  [^注1]: 索引块指向一个文件,块内每一条指向文件的<u>一个块</u>
  [^注2]: 索引表只在打开文件时才会在内存中将磁盘的索引结点拷贝一份,而FAT常驻内存,因此索引结点要比FAT更优

  [^注3]: 若涉及到移动顺序访盘1次+需移动文件块数*2(移动一个块需要读出再写入) 链接分配则n+2(寻找一个空闲块+链接)

  - 链接分配和索引分配计算文件大小的问题

    - 链表分配:<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571310165912.png" alt="1571310165912" style="zoom:67%;" />

      [^过程]: 4B=32bit的指针可以寻址$2^{32}$的空间=4G;一个块存放文件的空间=1024B-4B=1020B,最大长度=4G*1020B

    - 顺序分配:<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571310510178.png" alt="1571310510178" style="zoom:57%;" />

      [^注]: $4GB=1024^2*4096B$

  

- 文件的存储空间管理

  - 空闲表法：<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570968737753.png" alt="1570968737753" style="zoom:67%;" />
  - 空闲盘块/盘区链表法
  - 位示图<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570968858111.png" alt="1570968858111" style="zoom:67%;" />
  - 成组链表法													                      <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570968951628.png" alt="1570968951628" style="zoom:67%;" />



### I/O管理(与计组一起看)

- 缓冲

  - 单缓冲示意图

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570535609314.png" alt="1570535609314" style="zoom:67%;" />

  - 双缓冲示意图

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570535699176.png" alt="1570535699176" style="zoom:67%;" />

- 

## DS

### 栈和队列

- 中缀表达式转后缀表达式

  - 在表达式较复杂时或求有关栈中操作符数目时用

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570689751226.png" alt="1570689751226" style="zoom:67%;" />

  - 在表达式较简单时使用

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570689450590.png" alt="1570689450590" style="zoom:70%;" />



### 树与二叉树

- 二叉排序树
  - 判断是否是二叉排序树<u>查找路径</u>的方法:
    - 1、若首结点的下一个结点的值<首结点的值,则后续所有结点都应<;
    - 2、去掉此时的首结点,返回1 递归操作
  
- 哈夫曼树:最小<u>带权路径长度</u>=$\Sigma{wi*li}$ wi为第i个结点的权值，li为该<u>叶节点到根节点的路径长度</u>(即到根节点的距离)；合成后的哈夫曼的根节点只是这棵哈夫曼树的<u>最小花费</u>

- 平衡二叉树(BBT)

  - 平衡因子:$h_l-h_r<=1$

- B树<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570956646764.png" alt="1570956646764" style="zoom:60%;" />
  
  - B树的阶:<u>所有结点</u>的孩子节点数的最大值
  
  - m阶B树的性质
    - 树中每个结点**至多**m棵子树(m-1)关键字
    - 若根节点不是终端节点,则**至少**含<u>2棵子树</u>
    - 除根结点外的所有非叶节点至少有$\lceil m/2\rceil$棵子树(即至少含有$\lceil m/2\rceil-1$个关键字)
    - 所有叶节点在同一层上且<u>不带任何信息</u>,<u>平衡因子=0</u>
    - B树的高度一般不包括最后一层
    
  - B树有关计算公式(b树的高度范围)
  
    - <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570953506377.png" alt="1570953506377" style="zoom:60%;" />
  
    - 对查找不成功的<u>叶结点(n+1)</u>(计算最大高度):<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570953960047.png" alt="1570953960047" style="zoom:57%;" />
  
      [^推导过程]: 根节点最少1个结点->第二成至少2个结点->以后的每一层在上一层的基础上$*\lceil m/2\rceil$
      [^注]: (个人做题的发现)由公式得出此时对应的B树和B+树把所有关键字存在叶子结点有点像
  
  - B树的基本操作与平衡二叉树的对比:参考:http://data.biancheng.net/view/60.html
  
    - 插入
  
      B树<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570954554169.png" alt="1570954554169" style="zoom:57%;" />
  
      BBT:像普通排序二叉树一样插入到叶节点，然后进行旋转
  
    - 删除
  
      B树
  
      - <u>如果该结点为非终端结点且不处在最后一层</u>，只需要找到结点的`直接前驱或直接后继`替换,同时删除直接前驱或直接后继
  
        (一下讨论被删结点都在最后一层)
  
      - <u>被删关键字所在结点中的关键字数目`>=⌈m/2⌉</u>`，则只需从该结点删除该关键字 Ki 以及相应的指针 
      - 被删关键字所在结点中的关键字数目==`⌈m/2⌉-1`，<u>而与该结点相邻的兄弟结点的关键字数目>`⌈m/2⌉-1`</u>:将该兄弟结点中的`最小（或者最大）`的关键字上移到双亲结点中，对于该结点,其孩子结点应满足左小右大
      - <u>被删除关键字所在的结点和其相邻的兄弟结点中的关键字数目都=⌈m/2⌉-1</u>,则将父节点中有空指针的结点向下合并
  
      BBT：只需要找到结点的`直接前驱或直接后继`替换,同时删除直接前驱或直接后继
  
  - B树与B+树的对比
  
    |                                  | B树                                      | B+树                                                         |
    | -------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
    | n个关键字的结点含有子树          | n+1                                      | n                                                            |
    | 每个非根内部结点关键字个数的范围 | $\lceil{m/2}\rceil-1<=n<=m-1$            | $\lceil{m/2}\rceil<=n<=m$                                    |
    | 叶节点                           | 不包含信息<br />各结点包含的关键字不重复 | 包含所有信息,非叶节点只起索引作用<br />非叶节点出现的关键字也会包含在叶节点中 |
  
  

### <u>图</u>

- 图的一些概念

  - 简单图:1、无重复边 2、无自环 

  - 多重图:与简单图相对

  - 完全图(简单完全图):任意两顶点间都存在来回的边(无向图带两个方向)

  - 极大连通子图:该联通子图包含其所有的边(若是一个连通图,其极大连通子图就是自身)

  - 极小连通子图:保持图连通的情况下,边数最少的子图

  - 连通分量:<u>无向图</u>的极大连通子图;

  - 强连通图：从顶点u到顶点v和从顶点v到u都有路径,则称这对顶点是<u>强连通</u>,若图中任何一对顶点都是强连通的,则称此图为强连通图

  - 强连通分量:有向图的极大强连通子图

    [^注]: 强连通图\强连通分量只是针对**有向图**而言;一般的，无向图讨论连通性,有向图讨论强连通性;<u>连通分量针对连通图而言</u>

- 简单路径与简单回路:路径上的各顶点均不重复，称这样的路径为<u>简单路径</u>；若首尾顶点相同,则为<u>简单回路</u>

- 关键路径(考前复习:两个表的填写)

  - 即图的最长路径
  - <u>只有加快那些包含于所有关键路径的活动那个才能缩短工期</u>

### 数组和广义表

- **三元组**矩阵的转置，经历了三个步骤：

  - 矩阵的行数 n 和列数 m 的值交换；

  - 将三元组中的i和j调换；

  - 转换之后的表同样按照行序（置换前的列序）为主序，进行排序；

    (例:三元组的转置很简单,只需交换i,j的值,						答案:错误)

### 排序

```c++
///希尔排序
for(int id=n>>1;id>=1;id<<=1){
    for(int i=1;i<=n;i++)
    if(a[i]>a[i+id]){
        a[0]=a[i+id];
        for(int j=i-id;j>0&&a[0]<a[j];j-=id){
            a[j+id]=a[j];
        }
        a[j+id]=a[0];
    }
}
```

```r
///冒泡排序
void swap(int a,int b){///O(0) swap
    a=a+b;
    b=a-b;
    a=a-b;
}

for(int i=n;i>=1;i--){
    flag=false;
    for(int j=n;j>i;j--) if(a[i]<a[i-1]) swap(a[i],a[i-1]),flag=true;
    if(!flag) return;
}

///简单选择排序
for(int i=0;i<n-1;i++){
    int min=i;
    int j;
    for(j=i+1;j<n;j++){
        if(a[min]>a[j]) min=j;
    }
    if(min!=i) swap(a[j],a[min])
}
///注:简单选择排序和冒泡排序有相似,要区分
///区别在于:选择排序每次都会把最小的和当前这趟首元素交换位置,
```

```c++
///快排
int l=1,r=n;
int Partition(int a[],int l,int r){
    int pivot=a[l];
	while(l<r){
        while(l<r&&a[r]>=pivot) r--;
        a[l]=a[r];
        while(l<r&&a[l]<=pivot) l++;
        a[r]=a[l];
    }
    a[l]=pivot;
    return low;
}

void Qsort(int a[],int l,int r){
    if(l,r){
    int pivotpos=Partition(a,lr);
    Qsort(a,l,pivotpos);
    Qsort(a,pivotpos+1,r);
    }
}
```

```c++
///堆排序(大根堆)

void stiffDown(int a[],int k,int len){
    int a[0]=a[k];
    fot(int ch=k<<1;ch<=len;ch<<=2){
        if(ch<len&&a[ch+1]>a[ch]) ch++;
        if(a[0]>=a[ch]) break;
        a[k]=a[ch];
        k=ch;
    }
    a[k]=a[0];
}

void stiffUp(int a[],int k,int len){
    int a[0]=a[k];
	for(int pa=k>>1;pa>0;pa>>=1){
        if(a[0]>a[pa]) a[k]=a[pa]; else break;
        k=pa;
    }
    a[k]=a[0];
}

void buildMaxHeap(int a[],int len){
    for(int i=(len>>1);i>0;i--) stiffDown(a,i,len);
}

void deleteTop(int a[]){
    swap(a[1],a[len]);
    a[len--]=-1;
    stiffDown(a,1,len);
}

void insert(int a[],int k){
    a[len++]=k;
    stiffUp(a,len);
}

void heapSort(int a[],int len){
    buildMaxHeap(a,len);
    for(int i=len;i>0;i--){
        swap(a[1],a[i]);
        stiffDown(a,1,i-1)
    } 
}
```

```c++
///归并排序
void Merge(int a[],int l,int r){
    for(int i=l;i<=r;i++) B[i]=A[i];
    int mid=(l+r)>>1;
    int i;
    for(int i=0,k=l,j=mid+1;i<=mid&&j<=r;k++){
        if(B[i]<=B[j]) A[k]=B[i++];
        else A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=r) A[k++]=B[j]++;
}

void mergeSort(int a[],int l,int r){
    int mid=(l+r)>>1;
    mergeSort(a,l,mid);
    mergeSort(a,mid+1,r);
    merge(a,l,r);
}
```

- 基数排序

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000636226.png" alt="1570000636226" style="zoom: 67%;" />

各种内排序的比较

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570000696976.png" alt="1570000696976" style="zoom: 67%;" />

​			**算法复杂度**与初始状态无关的有：**选择排序、堆排序、归并排序、基数排序。**

​			元素总**比较次数**与初始状态无关的有：**选择排序**、**基数排序**  **折半插入排序**。

​			元素总**移动次数**与初始状态无关的有：**归并排序**、**基数排序**。

- 外部排序

  	多路归并

![1570001947191](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570001947191.png)
**注**：理论上，增大躺数可以减少归并次数；归并趟数=$ceil(log_mr)$

​	  

​		败者树(消除m路归并,增大归并路数的影响)

![1570002634614](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570002634614.png)
			置换-选择排序

![1570003607744](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003607744.png)
![1570003716126](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003716126.png)
![1570003755469](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570003755469.png)



​		最佳归并树(多路汉夫曼树):掌握不能构成严格哈夫曼树时如何新增结点

![1570004972627](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570004972627.png)

### 附录

- 涉及排列组合时常用卡特兰数:<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571384464157.png" alt="1571384464157" style="zoom:40%;" />

## 网络

### 计算机网络体系结构

- 计算机网络的分类

| 按分布范围划分           | 按传输技术划分   | 按使用者划分  | 按交换技术划分             | 按拓扑结构划分      | 按传输介质 |
| ------------------------ | ---------------- | ------------- | -------------------------- | ------------------- | ---------- |
| 广域网、域域网 局域网... | 广播网、点对点网 | 公用网 专用网 | 电路交换 报文交换 分组交换 | 星形 环形 总线 网状 | 蓝牙..     |

- 总时延=发送时延(**传输时延**)+**传播时延**+处理时延+排队时延
  - 发送时延=分组长度/信道宽度
  - 传播时延:信道长度/电磁波在信道上的传播速度
  - 一般题目未提及，忽略处理时延和排队时延
- 时延带宽积=第一个比特到达终点时，发送端已经发送的比特数。直观上=传播时延*信道带宽
- 数据帧的抽象结构
  - 服务数据单元(SDU)：完成要求功能而应传送的数据
  - 协议控制信息(PCI)：控制协议操作的信息
  - 协议数据单元(PDU):**对等层之间**传送数据的的单位
  - 三者间的挂你:n-PCI+n-SDU=n-PDU=(n-1)-SDU
- OSI与TCP/IP的比较

| OSI                                                          | TCP/IP                              | 协议栈                         |
| ------------------------------------------------------------ | ----------------------------------- | ------------------------------ |
| <u>应用层</u>(用户与网络的界面)                              | 应用层                              | telnet\ftp\dns\smtp\http       |
| <u>表示层</u>(数据格式的转换\编码方式的转换\数据压缩\加密解密等) | 应用层                              | --------                       |
| 会话层(管理<u>进程</u>间的会话)                              | 应用层                              | --------                       |
| 传输层                                                       | 传输层                              | TCP\UDP                        |
| 网络层                                                       | 网际层                              | IP\IPX\OSPF\ICMP\IGMP\ARP\RARP |
| 数据链路层                                                   | 网络接口层                          | SDLC\HDLC\PPP\STP              |
| 物理层                                                       | 网络接口层(网络接口$\to{}$物理接口) | EIA\CCITT                      |

**注**：OSI**网络层**支持无连接与面向连接通信，但在**传输层**只有面向连接

​		TCP/IP**网络层**只有无连接通信，**传输层**支持无连接和面向连接(认为可靠性是端到端)

### 物理层

- 物理层接口的特性

  | 机械特性                                                     | 功能特性                                                     | 电气特性                                                     | 过程特性                                        |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------- |
  | 规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况 | 规定<u>传输二进制位</u>时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等 | 指明某条线上出现的某一<u>电平表示何种意义，接口部件的信号线的用途</u> | 主要定义各条物理线路的<u>工作规程和时序关系</u> |

  

- 码元:一个固定时长的**信号波形**,数字通信中数字信号的**计量单位**；1码元可以携带多比特的信息量

- 数据通信系统；信原、信道、信宿

  [^注]: 信道与电路不等同。信道是线路的逻辑部件

- 码元传输速率:单位时间内传送码元的个数,单位**波特**=1码元/s

  [^注]: 波特和比特是不同概念,二进制码元可以看作1bit，此时的速率叫**信息传输速率**;若一码元携带nbit信息,M baud的码元的传输速率对应的信息传输率=M*nbit/s

- 奈奎斯特定理:理想状况(无干扰)的信道中,极限码元传输率为2W baud(W:理想低通信道的带宽,单位Hz)

  [^注]: 若有V种不同的码元(离散电平数目为V),则理想低通信道下的数据传输率=$2Wlog_2V$.(bit/s)

  - 结论:
    - 在任何信道中,码元的传输速率是有上限的 
    - 信道的频带越宽可用更高的速率进行码元的有效传输
    - 给出了**码元传输速率**的限制,没有对**信息传输速率**限制(一个码元可以对应多个二进制)

- 香农定理:**带宽受限**且**有干扰**的极限数据传输速率;信道极限数据传输速率=$Wlog_2(1+S/N)$

  [^注]: W为信道带宽,S为信道所传输信号的平均功率,N为信道内部的噪声功率,信噪比=$10log_{10}(S/N) 单位dB$

  - 结论:
    - 信道带宽越大或信噪比越大,传输率越大
    - 信噪比和带宽确定,传输率**上限**确定
    - 只要信息的传输率低于信道的极限传输率,就一定有办法来实现无差别传输

- 常见编码方式

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570192543222.png" alt="1570192543222" style="zoom:67%;" />

| 非归零码                              | 曼彻斯特编码   | 差分曼彻斯特      | 4B/5B |
| ------------------------------------- | -------------- | ----------------- | ----- |
| 无检错功能,无法判断一个码元的开始结束 | 以太网编码方式 | 自同步 抗干扰性好 |       |

- 调制为模拟信号

| 幅移键控(ASK)                             | 频移键控(FSK)                        | 相移键控(PSK)                                   | 正交调制                                                     |
| ----------------------------------------- | ------------------------------------ | ----------------------------------------------- | ------------------------------------------------------------ |
| 通过振幅来控制信号；比较容易实现,抗干扰差 | 通过频率来控制信号;容易实现,抗干扰强 | 通过相位来控制信号,分**绝对调相**和**相对调相** | 频率相同前提下,结合ASK和PSK；设波特率=B,m个相位,n种振幅,数据传输率=$Blog_2(m*n)$(bit/s) |

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570193187440.png" alt="1570193187440" style="zoom:67%;" />

- 采样定理
  - **抽样**是指对模拟信号就行周期性扫描,把时间上**连续的信号**变成时间上**离散的信号**，<u>当抽样的频率大于或等于模拟数据的频带带宽的**两倍**时,所得的离散信号可以无失真地代表被抽样地模拟数据</u>
  - **量化**是指把抽样取得的电平幅值按一定分级标度转化位对应的数字值，并取整
  - **编码**是把量化结果转换为与之对应地二进制编码
- 虚电路与数据报的比较

 <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570200346727.png" alt="1570200346727" style="zoom:67%;" />

- 各层设备

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571227094883.png" alt="1571227094883" style="zoom:67%;" />

|          | 网络层 | 数据链路层  | 物理层                         |
| -------- | ------ | ----------- | ------------------------------ |
| 主要设备 | 路由器 | 交换机 网桥 | 中继器(转发器):集线器(半双工): |

[^注]: 放大器放大的使<u>模拟信号</u>,中继器放大的是<u>数字信号</u>；中继器无存储转发功能,因此<u>不能连接协议不同的网段</u>
[^注]: 传输媒体不是物理层

- 各设备能否隔离广播域、冲突域

<img src="https://img-blog.csdn.net/20170107145830295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVmZmxlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°" style="zoom: 80%;" />

### 数据链路层

- 组帧

| 字符计数法                           | 首位定界符法              | 比特填充法                                      |
| ------------------------------------ | ------------------------- | ----------------------------------------------- |
| 帧头部使用一个计数字段来表明内字符数 | 用ASCII码来定界一帧的开始 | 01111110(发送方:信息位遇到5个连续的1,自动插入0) |

- 滑动窗口流量控制

  - 发送窗口控制发送端的发送速率

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570367309301.png" alt="1570367309301" style="zoom:67%;" />

  [^注]: $W_T$表示还没有<u>收到对方确认信息</u>的情况下发送方最对可以发送多少个数据帧；接收方控制发送方发送数据的速率

  - 数据链路层和传输层滑动窗口的差别

    | 传输层滑动窗口             | 数据链路层滑动窗口                                         |
    | -------------------------- | ---------------------------------------------------------- |
    | 端到端用户之间             | 点对点相邻节点                                             |
    | (拥塞)窗口大小可以动态变化 | 窗口不可动态变化;<u>当接收窗口为1时,可保证帧的有序到达</u> |
    | 发送最小单位:字节          | 发送最小单位:数据帧                                        |

  - 停止-等待流量控制：发送(接收方)方每发送(接收)一帧，都要等接收方的应答信号才能发送下一帧；<u>如果接收方不反馈应答信号则发送方必须一直等待</u>

  - 单帧滑动窗口与停止—等待协议,(利用率低)

    - 可能出现以下两种差错
      - 到达目的站的帧已破坏； 解决:<u>源站(</u>发送方)配备计时器;计时器满则重发
      - 数据帧正确而确认帧破坏:发送方重传数据帧,<u>接收方</u>由于已收到同样的帧而丢弃该帧,同时重发确认帧
    - 超时重发和判定重复帧的需要,收发双方都设置一个<u>帧缓冲区</u>
      

    | 停止等待(SW)                  | 后退N帧(GBN)                                                 | 选择重传(SR)                                                 |
    | ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 收到上一帧的ACK后才发送下一帧 | 收到ACK前可以连续发送多帧,当发送方窗口内某个已发送的数据产生超时重发时,其后续在发送窗口内已发送的数据帧也必须重传 <br />GBN对某一数据帧的确认就表明该数据帧及以前发送的所有帧都已正确接收。 <br />稍待确认:接收方可以在当自己有数据要发送时才发送确认帧。<br />接收端仅允许<u>按序接收</u>，<u>但应重复发送已经发送过的最后一个确认帧</u> | 相比于GBN加大接收窗口;<br />运用了更有效的差错处理策略:一旦接收方怀疑帧出错,就发送一个NAK给发送方,要求发送方对NAK指定帧重传<br />注:SR不支持<u>累计确认</u>,逐个确认正确接收的分组 |
    | 接收窗口=发送窗口=1           | 1<=发送窗口<=$2^n-1$,接收窗口=1                              | 接收窗口($W_T$)+发送窗口($W_R$)<=$2^n$;$W_{TMAX}=W_{TMIN}=2^{n-1}$<br />注：当$W_R=1$时退化成GBN,$W_R=W_T=1$时退化成SW |
    

  [^注]: GBN

- `信道划分`介质访问控制

  - 频分复用(FDM)

  - 时分复用(TDM)

  - 波分复用(WDM):光的频分复用

  - 码分复用(CDM):CDMA码分多址是码分复用的一种形式<u>与CSMA区分</u>

    [^CDMA的相关题目]: 
    [^]: <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571229686841.png" alt="1571229686841" style="zoom:50%;" />

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571229729291.png" alt="1571229729291" style="zoom:50%;" />

- `随机访问`介质访问控制

  - CSMA不同协议的比较

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570537489197.png" alt="1570537489197" style="zoom:67%;" />

  - CSMA/CD:
    - 二进制指数退避算法:![1570538534889](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570538534889.png)
    - 争用期:2×单程传播时延，只有经过争用期还没检测到冲突才能确定这次发送不会冲突

| ALOHA                                                        | CSMA                                  | CSMA/CD                                                      | CSMA/CA                                                      |
| ------------------------------------------------------------ | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 不进行任何检测就发送数据;若发生冲突则让各站等待一段<u>随机时间</u>；<br />时隙ALOHA:把各站的时间上都同步起来,并把时间分为一段段等长的时隙,规定只能在每个时隙开始时发送一个帧 | 与ALOHA区别主要多了<u>载波监听</u>    | 适用于<u>总线(有线)网络和(只能)半双工网络</u>,               | 适用于无线网络                                               |
| G:网络负载(T0时刻内所有站点发送成功的和未成功而重传的帧数)<br />(普通ALOHA)吞吐量S=$Ge^{-2G}$<br />时隙ALOHA:S=$Ge^{-G}$ | 1-坚持型 <br />非坚持型<br />p-坚持型 | 先听先法,边听边发(区别CSMA),冲突停发,随机重发<br />拥塞信号:48bit<br />争用期、二进制指数退避算法<br />最小帧长=总线传播时延×数据传输速率×2(不足填充) | 1、预约信道:发送的同时向其他站点通知自己<u>传输数据的时长</u><br />2、ACK帧:站点接收后都需要向发生方发回ACK帧(<u>CSMA CSMA/CD都不用</u>)<br />3、RTS/CTS帧 (可选避免机制,用于<u>隐蔽站问题</u>) |

- 局域网
  - 常见的局域网拓扑结构:星型结构、环形结构、总线结构、星形和总线型复合结构

  - EEE802定义的局域网参考模型只对应于OSI的<u>数据链路层和物理层</u>,并将数据链路层拆分成<u>逻辑链路控制子层(LLC)和媒体介入控制MAC子层</u>

    | LLC子层                                                      | MAC子层                                                      |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 向网络层提供<u>无确认无连接,面向连接,带确认无连接，高速传送</u>四种不同的连接服务类型 | 存放接入到传输媒体有关的内容，向上屏蔽对物理层的访问的各种差异；主要功能:<u>组帧和拆卸帧</u> |

  - 局域网介质访问控制方法:CSMA/CD、令牌总线、令牌环；前两者主要用于<u>总线局域网</u>，后者主要用于<u>环形网络</u>

    - 三种特殊的局域网拓扑实现

      | 以太网                                       | FDDI(光纤分布数据接口,IEEE802.8)          | 令牌环                                   |
      | -------------------------------------------- | ----------------------------------------- | ---------------------------------------- |
      | 逻辑拓扑:总线型<br />物理拓扑:星形或拓展星形 | 逻辑拓扑:环形结构<br />物理拓扑：双环结构 | 逻辑拓扑:环形结构<br />物理拓扑:星形拓扑 |

      [^注]: 以太网采用<u>无连接</u>的工作方式,不对发送数据编号,也不要求接收方发送确认,<u>提供不可靠服务</u>

  - 以太网的传输介质与网卡(重要,可作为题目隐含条件)

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570780865066.png" alt="1570780865066" style="zoom:67%;" />

  [^注]: 10base-T非屏蔽双绞线以太网拓扑结构为星形,星形中心为集线器,但使用以太网在逻辑上仍然是一个总线网

  - 以太网的MAC帧(会默)

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570781188873.png" alt="1570781188873" style="zoom:60%;" />

  

- 网桥
  - 设每个网段的数据率都是10Mb/s,那么三个网段合起来的最大吞吐量就是30Mb/s;如果把连接不同网段的网桥换成集线器或转发器则仍是10Mb/s
  - 网桥的特点:
    - 具备寻址和路径选择能力
    - 从源网络接收帧,以<u>目的网络</u>的介质访问控制协议向目的网络转发该帧
    - 可以在不同类型的LAN间存储转发[^一般存储转发类都可以进行协议转换]
  - 透明网桥(过程同交换机的过滤和转发)
  - 源路由网桥(选择的是最佳路由)
- 交换机(全双工)
  - 过滤和转发
    - 若交换机表中没有目的MAC地址字段,交换机把该帧广播到所有端口，并将该地址加入到查找表中
    - 若表中目的MAC地址对应的端口与发送端口一致，则过滤(丢弃)该帧
    - 若表中目的MAC地址对应的端口与发送端口不同,则转发到对饮端口
  - 两种交换模式
    - 直通式:只检查帧的目的地址,直接转发
    - 存储转发式:先将该帧接收到缓存中,检查数据是无误后转发
  - 

### 网络层

- ICMP(Internet Control Message Protocol)

  - <u>用于目标主机或目标主机路径上的路由器向源主机报告差错和异常情况</u>，共有以下五种情况

    - 终点不可达:当路由器或主机不能交付数据报时,向源点发送不可达报文
    - 源点抑制:由于**拥塞**而丢弃数据时,发送源点抑制报文
    - 时间超过:收到生存时间(TTL)=0的数据报时,除了丢弃该报文外,还要发送时间超过报文
    - 参数问题:当收到的数据报的首部中有的字段值不正确时,丢弃该报文,并发送参数问题报文
    - 改变路由(重定向):让主机下次将数据报发送给另外的路由器(可通过更好的路由)

  - 不应该发送ICMP差错报告的几种情况

    - 对ICMP差错报文

    - 对第一个分片的数据报片的所有后续数据报片都不发送

    - 对具有<u>组播地址</u>的数据报

    - 对具有特殊地址(如0.0.0.0 127.0.0.0)的数据报

      | PING                   | Tracert          |
      | ---------------------- | ---------------- |
      | ICMP会送请求和回答报文 | ICMP时间超过报文 |
      | 应用层                 | 网络层           |


- IP
  
  - MTU:最大传送单元;不同的链路协议MTU不同;
  - 片:当IP 数据报总长度>MTU时,需要将数据报分装在多个较小的IP数据报中,这些较小的数据报叫片,<u>片在目的网络层被重装</u>，它们都有<u>标识号:用来检验数据报是否来自同一原始数据报的片,</u>
  - IP数据报格式(会默)

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570706046030.png" alt="1570706046030" style="zoom:80%;" />

| IP首部的部分重要字段含义 |                                                              |
| :----------------------- | ------------------------------------------------------------ |
| 首部长度                 | 4位,以**<u>32位(4B)</u>**为单位,最大值60B(15*4B),最常用的首部长度是20B,此时不适用任何选项(可选项) |
| 总长度                   | 16位,首部长度+数据长度 <u>**单位:B**,</u>因此数据报的最大长度=$2^{16}-1$=65536 |
| 标识                     | 16位,计数器,每产生一个数据报就+1,但它并不是序号<u>(IP为无连接)</u> |
| 标志                     | 3位,MF=1,表示还有分片,MF=表示最后一个分片;DF=0,允许分片      |
| 片偏移                   | 13位.指出较长的分组在分片后,某片在原分组中的相对位置,**<u>以8B位单位</u>(**<u>即每个分片的长度一i的那个是8B的整数倍</u>) |
| 首部检验和               | 16位,只检验分组的首部,而不检验数据部分                       |
| 生存时间TTL              | 8位;数据报在网络中<u>可通过的路由器</u>的最大值;路由器在转发分组前先把TTL-1,若TTL=0,则丢弃分组 |
| 协议                     | 8位;值为6为TCP,值为17为UDP                                   |
| 源地址字段               | 4位,标识发送方的<u>IP地址</u>                                |
| 目的地址                 | 4位标识接收方的I<u>P地址</u>                                 |

- 网络层转发分组的流程

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570711610004.png" alt="1570711610004" style="zoom:67%;" />

[^注]: 得到下一跳路由器的IP地址后不是直接将该地址填入到待发送的数据报,而是将该IP地址转换成MAC地址(ARP),放到帧首部,然后根据这个MAC地址找到下一跳路由

- 分类的IPV4地址(常考)

  - 三种类别的IP地址的使用范围

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570710633953.png" alt="1570710633953" style="zoom:80%;" />

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570710306559.png" alt="1570710306559" style="zoom:80%;" />

  [^注]: A\B\C默认子网掩码分别是255.0.0.0/255.255.0.0/255.255.255.255.0

  - <u>主机号全为0,标识网络自身；主机号全1为本网络广播地址</u>
    32位全0标识本网络上的本主机, 32位全1表示整个TCP/IP网络的广播地址,称为<u>受限地址</u>；<u>实际使用时由于路由器对广播域隔离,等效为本网络的广播地址</u>

  - 127.0.0.0留作环路自检，不会出现在任何网络上

    [^注]: 路由器总是拥有两个或两个以上的IP地址,每一个端口都有一个网络号不同的IP地址;同一广播域的网络号相同

- 网络地址转换NAT:通过专用网络地址转换为公用地址,隐藏内部管理的IP地址；使整个专用网只要一个IP地址
  
  - 私有IP(可重用IP地址):

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570711139500.png" alt="1570711139500" style="zoom:80%;" />

[^注]: 普通路由器在转发IP数据报时,不改变其源IP地址和目的IP地址。<u>而NAT转发时,一定要更换其IP地址</u>；普通路由器只工作在网络层，而<u>NAT路由器转发数据报时需查看和转换传输层的端口号</u>

- 域内路由与域间路由

| 内部网关协议(IGP)                                            | 外部网关协议(EGP) |
| ------------------------------------------------------------ | ----------------- |
| RIP\OSPF                                                     | BGP               |
| IGP用于一个自治系统内部,与互联网其他自治系统选用什么路由选择协议无关;EGP用于不同自治系统间 |                   |



### 传输层

- TCP协议:全双工，有连接，面向字节流

  - 发送缓存:1、发送程序准备发送的数据2、TCP已发送但尚未收到确认的数据
  - 接收缓存:1、按序到达但尚未被程序读取的数据2、不按序到达的数据
  - 套接字(socket):TCP连接的端口,如192.168.1.1:80;一条TCP连接唯一地被两个套接字所确定
  - TCP报文段的首部                                <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570972017895.png" alt="1570972017895" style="zoom:67%;" />
    - 源端口\目的端口字段:各2B.[^ 注：端口是传输层与应用层的服务接口]
    - 序号字段(seq):4B.本报文段所发送的数据的第一个字节的序号
    - 确认号字段(ack):4B.是期望收到**对方的**下一个报文段的数据的第一个字节的**序号**
    - 数据偏移(首部长度):4<u>bit</u>.指出TCP报文段的`数据起始`距离`TCP报文段的起始`的距离[^与IP数据报的片偏移区分]
    - 确认位(ACK):ACK=1时确认号字段有效，ACK=0时无效.<u>规定在连接建立后所有传送的报文段ACK=1</u>
    - 复用位(RST):当RST=1时,表明连接中出现严重差错,必须释放连接
    - 同步位SYN:当SUN=1,ACK=0,表明连接请求,对方若同意建立连接则回复SYN=1,ACK=1
    - 窗口字段:2B 指出允许发送方发送的数据量,单位<u>字节</u>
    - 校验和:2B 计算校验和时在报文段前加上12B的伪首部(只需将UDP伪首部的协议字段17改成6)
    - 填充个字段:使首部长度是4B的整数倍
  - TCP连接地建立                                            <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570974673311.png" alt="1570974673311" style="zoom:60%;" />

  <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570973940378.png" alt="1570973940378" style="zoom:67%;" />

  [^注]: 第一步和“三次握手”一样,注意第二步,客户机收到ack=u+1地报文段,从客户机到服务器地连接就释放了,此时TCP处于半关闭状态,但服务器若发送数据,客户机仍要接收;最终A发送seq=u+1的报文后,连接没有理及断开,而是等待2MSL(最长报文段寿命)另:服务器也能选择关闭该连接;

  

<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570974042053.png" alt="1570974042053" style="zoom:67%;" />

### 应用层

- HTTP：服务器与浏览器之间；面向事务；无状态(不保留客户上一次访问的状态)，通常用COOKIE(存储在用户机的<u>文本文件</u>)+数据库来追踪用户的活动。

  - HTTP采用运输层采用TCP协议保证数据的可靠传输,但<u>HTTP本身是无连接的</u>

  - HTTP的三种工作模式

    <img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1570783693745.png" alt="1570783693745" style="zoom:67%;" />

    [^注]: 第一种请求一个文档的所需时间为该文档的传输时间+2RTT(一个创建链接,一个文档接收)

- SMTP:提供可靠且有效的<u>电子邮件传输协议</u>

- POP3:简单的<u>邮件读取协议</u>

- MIME:SMTP只能传送一定长度(7bit)的ASCII码,MIME定义了传送非ASCII的规则

- 应用层协议常用端口号<img src="C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1571056105076.png" alt="1571056105076" style="zoom:67%;" />



 