# 408遗忘知识点总结

## 组原

### 第一章

- 第一台电子数字计算机:ENIAC

  | 单指令和单数据流系统SISD | 单指令多数据流系统SIMD | 多指令单数据流系统MISD | 多指令多数据流系统MIMD |
  | ------------------------ | ---------------------- | ---------------------- | ---------------------- |
  | 冯诺依曼体系结构         | 阵列处理器和向量处理器 | ________               | 多处理器和多计算机系统 |

- 冯诺依曼机的特点(SISD)

  ![1569841926106](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569841926106.png)

- 累加器 :是一种**寄存器**，用来储存计算产生的中间结果。

- 一个汉字通常占2B

### 第三章

- 存储元:存放一个二进制位的物理器件

- 存储单元:存放一个**机器字**的所有存储元;地址码相同的多个**存储元**构成存储单元

- SRAM DRAM各自得特点


![1569747278920](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569747278920.png)

2、三种映射方式得地址结构

![1569748348509](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748348509.png)
![1569748562645](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748562645.png)
![1569748592130](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569748592130.png)





## OS

### 第一章

- 并发和并行的区别:

  | 并发                                   | 并行                                 |
  | -------------------------------------- | ------------------------------------ |
  | 两个或以上事件在**同一时间间隔**内发生 | 具有可以**同时**进行运算或操作的特性 |

  例:	并发是一手筷子，一手电话，说一句话，咽一口饭。
  		 并行是咽一口饭同时说一句话，而这光靠一张嘴是办不到的，至少两张嘴。

- 原语

  ![1569839846080](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569839846080.png)
  

### 第三章

三种分页方式的地址结构

1.分页

![1569833278353](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833278353.png)

- 多级页表

![1569833343596](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833343596.png)
3.分段

![1569833453418](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833453418.png) 	

- 段表的内容

![1569833495519](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833495519.png)

4、段页式

![1569833654898](C:\Users\Rocky\AppData\Roaming\Typora\typora-user-images\1569833654898.png)

## DS

### 数组和广义表

- **三元组**矩阵的转置，经历了三个步骤：

  - 矩阵的行数 n 和列数 m 的值交换；

  - 将三元组中的i和j调换；

  - 转换之后的表同样按照行序（置换前的列序）为主序，进行排序；

    (例:三元组的转置很简单,只需交换i,j的值,						答案:错误)

### 排序

```c++
///希尔排序
for(int id=n>>1;id>=1;id<<=1){
    for(int i=1;i<=n;i++)
    if(a[i]>a[i+id]){
        a[0]=a[i+id];
        for(int j=i-id;j>0&&a[0]<a[j];j-=id){
            a[j+id]=a[j];
        }
        a[j+id]=a[0];
    }
}
```

```c++
///冒泡排序
void swap(int a,int b){///O(0) swap
    a=a+b;
    b=a-b;
    a=a-b;
}

for(int i=n;i>=1;i--){
    flag=false;
    for(int j=n;j>i;j--) if(a[i]<a[i-1]) swap(a[i],a[i-1]),flag=true;
    if(!flag) return;
}
```

```c++
///快排
int l=1,r=n;
int Partition(int a[],int l,int r){
    int pivot=a[l];
	while(l<r){
        while(l<r&&a[r]>=pivot) r--;
        a[l]=a[r];
        while(l<r&&a[l]<=pivot) l++;
        a[r]=a[l];
    }
    a[l]=pivot;
    return low;
}

void Qsort(int a[],int l,int r){
    if(l,r){
    int pivotpos=Partition(a,lr);
    Qsort(a,l,pivotpos);
    Qsort(a,pivotpos+1,r);
    }
}
```

```c++
///堆排序(大根堆)

void stiffDown(int a[],int k,int len){
    int a[0]=a[k];
    fot(int ch=k<<1;ch<=len;ch<<=2){
        if(ch<len&&a[ch+1]>a[ch]) ch++;
        if(a[0]>=a[ch]) break;
        a[k]=a[ch];
        k=ch;
    }
    a[k]=a[0];
    return;
}

void stiffUp(int a[],int k,int len){
    int a[0]=a[k];
	for(int pa=k>>1;pa>0;pa>>=1){
        if(a[0]>a[pa]) a[k]=a[pa]; else break;
        k=pa;
    }
    a[k]=a[0];
}

void buildMaxHeap(int a[],int len){
    for(int i=(len>>1);i>0;i--) stiffDown(a,i);
}

void HeapSort(int a[],int len){
    buildMaxHeap(a,len);
    for(int i=len;i>0;i--){
        swap(a[1],a[i]);
        stiffDown(a,1,i-1)
    } 
}


```



## 网络